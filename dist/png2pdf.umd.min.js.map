{"version":3,"file":"png2pdf.umd.min.js","sources":["../src/libs/globalObject.js","../src/libs/AtobBtoa.js","../src/libs/console.js","../src/jspdf.js","../src/modules/addimage.js","../node_modules/fflate/esm/index.mjs","../src/libs/png.js","../src/modules/png_support.js","../src/index.js"],"sourcesContent":["export var globalObject = (function() {\n  return \"undefined\" !== typeof window\n    ? window\n    : \"undefined\" !== typeof global\n    ? global\n    : \"undefined\" !== typeof self\n    ? self\n    : this;\n})();\n","import { globalObject } from \"./globalObject.js\";\n\nvar atob, btoa;\n\n(function() {\n  atob = globalObject.atob.bind(globalObject);\n  btoa = globalObject.btoa.bind(globalObject);\n  return;\n\n})();\n\nexport { atob, btoa };\n","import { globalObject } from \"./globalObject.js\";\n\nfunction consoleLog() {\n  if (globalObject.console && typeof globalObject.console.log === \"function\") {\n    globalObject.console.log.apply(globalObject.console, arguments);\n  }\n}\n\nfunction consoleWarn(str) {\n  if (globalObject.console) {\n    if (typeof globalObject.console.warn === \"function\") {\n      globalObject.console.warn.apply(globalObject.console, arguments);\n    } else {\n      consoleLog.call(null, arguments);\n    }\n  }\n}\n\nfunction consoleError(str) {\n  if (globalObject.console) {\n    if (typeof globalObject.console.error === \"function\") {\n      globalObject.console.error.apply(globalObject.console, arguments);\n    } else {\n      consoleLog(str);\n    }\n  }\n}\nexport var console = {\n  log: consoleLog,\n  warn: consoleWarn,\n  error: consoleError\n};\n","/* eslint-disable no-console */\n\nimport { globalObject } from \"./libs/globalObject.js\";\nimport { btoa } from \"./libs/AtobBtoa.js\";\nimport { console } from \"./libs/console.js\";\n/**\n * jsPDF's Internal PubSub Implementation.\n * Backward compatible rewritten on 2014 by\n * Diego Casorran, https://github.com/diegocr\n *\n * @class\n * @name PubSub\n * @ignore\n */\nfunction PubSub(context) {\n  if (typeof context !== \"object\") {\n    throw new Error(\n      \"Invalid Context passed to initialize PubSub (jsPDF-module)\"\n    );\n  }\n  var topics = {};\n\n  this.subscribe = function(topic, callback, once) {\n    once = once || false;\n    if (\n      typeof topic !== \"string\" ||\n      typeof callback !== \"function\" ||\n      typeof once !== \"boolean\"\n    ) {\n      throw new Error(\n        \"Invalid arguments passed to PubSub.subscribe (jsPDF-module)\"\n      );\n    }\n\n    if (!topics.hasOwnProperty(topic)) {\n      topics[topic] = {};\n    }\n\n    var token = Math.random().toString(35);\n    topics[topic][token] = [callback, !!once];\n\n    return token;\n  };\n\n  this.unsubscribe = function(token) {\n    for (var topic in topics) {\n      if (topics[topic][token]) {\n        delete topics[topic][token];\n        if (Object.keys(topics[topic]).length === 0) {\n          delete topics[topic];\n        }\n        return true;\n      }\n    }\n    return false;\n  };\n\n  this.publish = function(topic) {\n    if (topics.hasOwnProperty(topic)) {\n      var args = Array.prototype.slice.call(arguments, 1),\n        tokens = [];\n\n      for (var token in topics[topic]) {\n        var sub = topics[topic][token];\n        try {\n          sub[0].apply(context, args);\n        } catch (ex) {\n          if (globalObject.console) {\n            console.error(\"jsPDF PubSub Error\", ex.message, ex);\n          }\n        }\n        if (sub[1]) tokens.push(token);\n      }\n      if (tokens.length) tokens.forEach(this.unsubscribe);\n    }\n  };\n\n  this.getTopics = function() {\n    return topics;\n  };\n}\n\n/**\n * Creates new jsPDF document object instance.\n * @name jsPDF\n * @class\n * @param {Object} [options] - Collection of settings initializing the jsPDF-instance\n * @param {string} [options.orientation=portrait] - Orientation of the first page. Possible values are \"portrait\" or \"landscape\" (or shortcuts \"p\" or \"l\").<br />\n * @param {string} [options.unit=mm] Measurement unit (base unit) to be used when coordinates are specified.<br />\n * Possible values are \"pt\" (points), \"mm\", \"cm\", \"in\", \"px\", \"pc\", \"em\" or \"ex\". Note that in order to get the correct scaling for \"px\"\n * units, you need to enable the hotfix \"px_scaling\" by setting options.hotfixes = [\"px_scaling\"].\n * @param {string/Array} [options.format=a4] The format of the first page. Can be:<ul><li>a0 - a10</li><li>b0 - b10</li><li>c0 - c10</li><li>dl</li><li>letter</li><li>government-letter</li><li>legal</li><li>junior-legal</li><li>ledger</li><li>tabloid</li><li>credit-card</li></ul><br />\n * Default is \"a4\". If you want to use your own format just pass instead of one of the above predefined formats the size as an number-array, e.g. [595.28, 841.89]\n * @param {boolean} [options.putOnlyUsedFonts=false] Only put fonts into the PDF, which were used.\n * @param {boolean} [options.compress=false] Compress the generated PDF.\n * @param {number} [options.precision=16] Precision of the element-positions.\n * @param {number} [options.userUnit=1.0] Not to be confused with the base unit. Please inform yourself before you use it.\n * @param {string[]} [options.hotfixes] An array of strings to enable hotfixes such as correct pixel scaling.\n * @param {Object} [options.encryption]\n * @param {string} [options.encryption.userPassword] Password for the user bound by the given permissions list.\n * @param {string} [options.encryption.ownerPassword] Both userPassword and ownerPassword should be set for proper authentication.\n * @param {string[]} [options.encryption.userPermissions] Array of permissions \"print\", \"modify\", \"copy\", \"annot-forms\", accessible by the user.\n * @param {number|\"smart\"} [options.floatPrecision=16]\n * @returns {jsPDF} jsPDF-instance\n * @description\n * ```\n * {\n *  orientation: 'p',\n *  unit: 'mm',\n *  format: 'a4',\n *  putOnlyUsedFonts:true,\n *  floatPrecision: 16 // or \"smart\", default is 16\n * }\n * ```\n *\n * @constructor\n */\nfunction jsPDF(options) {\n  var orientation = typeof arguments[0] === \"string\" ? arguments[0] : \"p\";\n  var unit = arguments[1];\n  var format = arguments[2];\n  var compressPdf = arguments[3];\n  var filters = [];\n  var userUnit = 1.0;\n  var precision;\n  var floatPrecision = 16;\n\n  options = options || {};\n\n  if (typeof options === \"object\") {\n    orientation = options.orientation;\n    unit = options.unit || unit;\n    format = options.format || format;\n    compressPdf = options.compress || options.compressPdf || compressPdf;\n    userUnit =\n      typeof options.userUnit === \"number\" ? Math.abs(options.userUnit) : 1.0;\n    if (typeof options.precision !== \"undefined\") {\n      precision = options.precision;\n    }\n    if (typeof options.floatPrecision !== \"undefined\") {\n      floatPrecision = options.floatPrecision;\n    }\n  }\n\n  filters =\n    options.filters || (compressPdf === true ? [\"FlateEncode\"] : filters);\n\n  unit = unit || \"mm\";\n  orientation = (\"\" + (orientation || \"P\")).toLowerCase();\n\n  var API = {\n    internal: {},\n    __private__: {}\n  };\n\n  API.__private__.PubSub = PubSub;\n\n  var pdfVersion = \"1.3\";\n  var getPdfVersion = (API.__private__.getPdfVersion = function() {\n    return pdfVersion;\n  });\n\n  API.__private__.setPdfVersion = function(value) {\n    pdfVersion = value;\n  };\n\n  format = format || \"a4\";\n\n  var ApiMode = {\n    COMPAT: \"compat\",\n    ADVANCED: \"advanced\"\n  };\n  var apiMode = ApiMode.COMPAT;\n\n  /**\n   * @return {boolean} True iff the current API mode is \"advanced\". See {@link advancedAPI}.\n   * @memberof jsPDF#\n   * @name isAdvancedAPI\n   */\n  API.isAdvancedAPI = function() {\n    return apiMode === ApiMode.ADVANCED;\n  };\n\n  var roundToPrecision = (API.roundToPrecision = API.__private__.roundToPrecision = function(\n    number,\n    parmPrecision\n  ) {\n    var tmpPrecision = precision || parmPrecision;\n    if (isNaN(number) || isNaN(tmpPrecision)) {\n      throw new Error(\"Invalid argument passed to jsPDF.roundToPrecision\");\n    }\n    return number.toFixed(tmpPrecision).replace(/0+$/, \"\");\n  });\n\n  // high precision float\n  var hpf = (API.hpf = API.__private__.hpf = function(number) {\n    if (isNaN(number)) {\n      throw new Error(\"Invalid argument passed to jsPDF.hpf\");\n    }\n    return roundToPrecision(number, floatPrecision);\n  });\n\n  var scale = (API.scale = API.__private__.scale = function(number) {\n    if (isNaN(number)) {\n      throw new Error(\"Invalid argument passed to jsPDF.scale\");\n    }\n    if (apiMode === ApiMode.COMPAT) {\n      return number * scaleFactor;\n    } else if (apiMode === ApiMode.ADVANCED) {\n      return number;\n    }\n  });\n\n  var fileId = \"00000000000000000000000000000000\";\n\n  var getFileId = (API.__private__.getFileId = function() {\n    return fileId;\n  });\n\n  var setFileId = (API.__private__.setFileId = function(value) {\n    if (typeof value !== \"undefined\" && /^[a-fA-F0-9]{32}$/.test(value)) {\n      fileId = value.toUpperCase();\n    } else {\n      fileId = fileId\n        .split(\"\")\n        .map(function() {\n          return \"ABCDEF0123456789\".charAt(Math.floor(Math.random() * 16));\n        })\n        .join(\"\");\n    }\n    return fileId;\n  });\n\n  /**\n   * @name setFileId\n   * @memberof jsPDF#\n   * @function\n   * @instance\n   * @param {string} value GUID.\n   * @returns {jsPDF}\n   */\n  API.setFileId = function(value) {\n    setFileId(value);\n    return this;\n  };\n\n  /**\n   * @name getFileId\n   * @memberof jsPDF#\n   * @function\n   * @instance\n   *\n   * @returns {string} GUID.\n   */\n  API.getFileId = function() {\n    return getFileId();\n  };\n\n  var creationDate;\n\n  var convertDateToPDFDate = (API.__private__.convertDateToPDFDate = function(\n    parmDate\n  ) {\n    var result = \"\";\n    var tzoffset = parmDate.getTimezoneOffset(),\n      tzsign = tzoffset < 0 ? \"+\" : \"-\",\n      tzhour = Math.floor(Math.abs(tzoffset / 60)),\n      tzmin = Math.abs(tzoffset % 60),\n      timeZoneString = [tzsign, padd2(tzhour), \"'\", padd2(tzmin), \"'\"].join(\"\");\n\n    result = [\n      \"D:\",\n      parmDate.getFullYear(),\n      padd2(parmDate.getMonth() + 1),\n      padd2(parmDate.getDate()),\n      padd2(parmDate.getHours()),\n      padd2(parmDate.getMinutes()),\n      padd2(parmDate.getSeconds()),\n      timeZoneString\n    ].join(\"\");\n    return result;\n  });\n\n  var convertPDFDateToDate = (API.__private__.convertPDFDateToDate = function(\n    parmPDFDate\n  ) {\n    var year = parseInt(parmPDFDate.substr(2, 4), 10);\n    var month = parseInt(parmPDFDate.substr(6, 2), 10) - 1;\n    var date = parseInt(parmPDFDate.substr(8, 2), 10);\n    var hour = parseInt(parmPDFDate.substr(10, 2), 10);\n    var minutes = parseInt(parmPDFDate.substr(12, 2), 10);\n    var seconds = parseInt(parmPDFDate.substr(14, 2), 10);\n    // var timeZoneHour = parseInt(parmPDFDate.substr(16, 2), 10);\n    // var timeZoneMinutes = parseInt(parmPDFDate.substr(20, 2), 10);\n\n    var resultingDate = new Date(year, month, date, hour, minutes, seconds, 0);\n    return resultingDate;\n  });\n\n  var setCreationDate = (API.__private__.setCreationDate = function(date) {\n    var tmpCreationDateString;\n    var regexPDFCreationDate = /^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\\+0[0-9]|\\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/;\n    if (typeof date === \"undefined\") {\n      date = new Date();\n    }\n\n    if (date instanceof Date) {\n      tmpCreationDateString = convertDateToPDFDate(date);\n    } else if (regexPDFCreationDate.test(date)) {\n      tmpCreationDateString = date;\n    } else {\n      throw new Error(\"Invalid argument passed to jsPDF.setCreationDate\");\n    }\n    creationDate = tmpCreationDateString;\n    return creationDate;\n  });\n\n  var getCreationDate = (API.__private__.getCreationDate = function(type) {\n    var result = creationDate;\n    if (type === \"jsDate\") {\n      result = convertPDFDateToDate(creationDate);\n    }\n    return result;\n  });\n\n  /**\n   * @name setCreationDate\n   * @memberof jsPDF#\n   * @function\n   * @instance\n   * @param {Object} date\n   * @returns {jsPDF}\n   */\n  API.setCreationDate = function(date) {\n    setCreationDate(date);\n    return this;\n  };\n\n  /**\n   * @name getCreationDate\n   * @memberof jsPDF#\n   * @function\n   * @instance\n   * @param {Object} type\n   * @returns {Object}\n   */\n  API.getCreationDate = function(type) {\n    return getCreationDate(type);\n  };\n\n  var padd2 = (API.__private__.padd2 = function(number) {\n    return (\"0\" + parseInt(number)).slice(-2);\n  });\n\n  var objectNumber = 0; // 'n' Current object number\n  var offsets = []; // List of offsets. Activated and reset by buildDocument(). Pupulated by various calls buildDocument makes.\n  var content = [];\n  var contentLength = 0;\n  var additionalObjects = [];\n\n  var pages = [];\n  var currentPage;\n  var hasCustomDestination = false;\n  var outputDestination = content;\n\n  var resetDocument = function() {\n    //reset fields relevant for objectNumber generation and xref.\n    objectNumber = 0;\n    contentLength = 0;\n    content = [];\n    offsets = [];\n    additionalObjects = [];\n\n    rootDictionaryObjId = newObjectDeferred();\n    resourceDictionaryObjId = newObjectDeferred();\n  };\n\n  var setOutputDestination = function(destination) {\n    if (!hasCustomDestination) {\n      outputDestination = destination;\n    }\n  };\n\n  var out = (API.__private__.out = function(string) {\n    string = string.toString();\n    contentLength += string.length + 1;\n    outputDestination.push(string);\n\n    return outputDestination;\n  });\n\n  var write = (API.__private__.write = function(value) {\n    return out(\n      arguments.length === 1\n        ? value.toString()\n        : Array.prototype.join.call(arguments, \" \")\n    );\n  });\n\n  var getArrayBuffer = (API.__private__.getArrayBuffer = function(data) {\n    var len = data.length,\n      ab = new ArrayBuffer(len),\n      u8 = new Uint8Array(ab);\n\n    while (len--) u8[len] = data.charCodeAt(len);\n    return ab;\n  });\n\n  var pageMode; // default: 'UseOutlines';\n\n  API.__private__.getPageMode = function() {\n    return pageMode;\n  };\n\n  var layoutMode; // default: 'continuous';\n\n  API.__private__.getLayoutMode = function() {\n    return layoutMode;\n  };\n\n  var documentProperties = {\n    title: \"\",\n    subject: \"\",\n    author: \"\",\n    keywords: \"\",\n    creator: \"\"\n  };\n\n  var fonts = {}; // collection of font objects, where key is fontKey - a dynamically created label for a given font.\n  var activeFontKey; // will be string representing the KEY of the font as combination of fontName + fontStyle\n  var scaleFactor; // Scale factor\n  var page = 0;\n  var pagesContext = [];\n  var events = new PubSub(API);\n  var hotfixes = options.hotfixes || [];\n\n  var renderTargets = {};\n\n  /**\n   * Multiplies two matrices. (see {@link Matrix})\n   * @param {Matrix} m1\n   * @param {Matrix} m2\n   * @memberof jsPDF#\n   * @name matrixMult\n   */\n  var matrixMult = (API.matrixMult = function(m1, m2) {\n    return m2.multiply(m1);\n  });\n\n  var newObject = (API.__private__.newObject = function() {\n    var oid = newObjectDeferred();\n    newObjectDeferredBegin(oid, true);\n    return oid;\n  });\n\n  // Does not output the object.  The caller must call newObjectDeferredBegin(oid) before outputing any data\n  var newObjectDeferred = (API.__private__.newObjectDeferred = function() {\n    objectNumber++;\n    offsets[objectNumber] = function() {\n      return contentLength;\n    };\n    return objectNumber;\n  });\n\n  var newObjectDeferredBegin = function(oid, doOutput) {\n    doOutput = typeof doOutput === \"boolean\" ? doOutput : false;\n    offsets[oid] = contentLength;\n    if (doOutput) {\n      out(oid + \" 0 obj\");\n    }\n    return oid;\n  };\n  // Does not output the object until after the pages have been output.\n  // Returns an object containing the objectId and content.\n  // All pages have been added so the object ID can be estimated to start right after.\n  // This does not modify the current objectNumber;  It must be updated after the newObjects are output.\n  var newAdditionalObject = (API.__private__.newAdditionalObject = function() {\n    var objId = newObjectDeferred();\n    var obj = {\n      objId: objId,\n      content: \"\"\n    };\n    additionalObjects.push(obj);\n    return obj;\n  });\n\n  var rootDictionaryObjId = newObjectDeferred();\n  var resourceDictionaryObjId = newObjectDeferred();\n\n  var getFilters = (API.__private__.getFilters = function() {\n    return filters;\n  });\n\n  var putStream = (API.__private__.putStream = function(options) {\n    options = options || {};\n    var data = options.data || \"\";\n    var filters = options.filters || getFilters();\n    var alreadyAppliedFilters = options.alreadyAppliedFilters || [];\n    var addLength1 = options.addLength1 || false;\n    var valueOfLength1 = data.length;\n\n    var processedData = {};\n    if (filters === true) {\n      filters = [\"FlateEncode\"];\n    }\n    var keyValues = options.additionalKeyValues || [];\n    if (typeof jsPDF.API.processDataByFilters !== \"undefined\") {\n      processedData = jsPDF.API.processDataByFilters(data, filters);\n    } else {\n      processedData = { data: data, reverseChain: [] };\n    }\n    var filterAsString =\n      processedData.reverseChain +\n      (Array.isArray(alreadyAppliedFilters)\n        ? alreadyAppliedFilters.join(\" \")\n        : alreadyAppliedFilters.toString());\n\n    if (processedData.data.length !== 0) {\n      keyValues.push({\n        key: \"Length\",\n        value: processedData.data.length\n      });\n      if (addLength1 === true) {\n        keyValues.push({\n          key: \"Length1\",\n          value: valueOfLength1\n        });\n      }\n    }\n\n    if (filterAsString.length != 0) {\n      if (filterAsString.split(\"/\").length - 1 === 1) {\n        keyValues.push({\n          key: \"Filter\",\n          value: filterAsString\n        });\n      } else {\n        keyValues.push({\n          key: \"Filter\",\n          value: \"[\" + filterAsString + \"]\"\n        });\n\n        for (var j = 0; j < keyValues.length; j += 1) {\n          if (keyValues[j].key === \"DecodeParms\") {\n            var decodeParmsArray = [];\n\n            for (\n              var i = 0;\n              i < processedData.reverseChain.split(\"/\").length - 1;\n              i += 1\n            ) {\n              decodeParmsArray.push(\"null\");\n            }\n\n            decodeParmsArray.push(keyValues[j].value);\n            keyValues[j].value = \"[\" + decodeParmsArray.join(\" \") + \"]\";\n          }\n        }\n      }\n    }\n\n    out(\"<<\");\n    for (var k = 0; k < keyValues.length; k++) {\n      out(\"/\" + keyValues[k].key + \" \" + keyValues[k].value);\n    }\n    out(\">>\");\n    if (processedData.data.length !== 0) {\n      out(\"stream\");\n      out(processedData.data);\n      out(\"endstream\");\n    }\n  });\n\n  var putPage = (API.__private__.putPage = function(page) {\n    var pageNumber = page.number;\n    var data = page.data;\n    var pageObjectNumber = page.objId;\n    var pageContentsObjId = page.contentsObjId;\n\n    newObjectDeferredBegin(pageObjectNumber, true);\n    out(\"<</Type /Page\");\n    out(\"/Parent \" + page.rootDictionaryObjId + \" 0 R\");\n    out(\"/Resources \" + page.resourceDictionaryObjId + \" 0 R\");\n    out(\n      \"/MediaBox [\" +\n        parseFloat(hpf(page.mediaBox.bottomLeftX)) +\n        \" \" +\n        parseFloat(hpf(page.mediaBox.bottomLeftY)) +\n        \" \" +\n        hpf(page.mediaBox.topRightX) +\n        \" \" +\n        hpf(page.mediaBox.topRightY) +\n        \"]\"\n    );\n    if (page.cropBox !== null) {\n      out(\n        \"/CropBox [\" +\n          hpf(page.cropBox.bottomLeftX) +\n          \" \" +\n          hpf(page.cropBox.bottomLeftY) +\n          \" \" +\n          hpf(page.cropBox.topRightX) +\n          \" \" +\n          hpf(page.cropBox.topRightY) +\n          \"]\"\n      );\n    }\n\n    if (page.bleedBox !== null) {\n      out(\n        \"/BleedBox [\" +\n          hpf(page.bleedBox.bottomLeftX) +\n          \" \" +\n          hpf(page.bleedBox.bottomLeftY) +\n          \" \" +\n          hpf(page.bleedBox.topRightX) +\n          \" \" +\n          hpf(page.bleedBox.topRightY) +\n          \"]\"\n      );\n    }\n\n    if (page.trimBox !== null) {\n      out(\n        \"/TrimBox [\" +\n          hpf(page.trimBox.bottomLeftX) +\n          \" \" +\n          hpf(page.trimBox.bottomLeftY) +\n          \" \" +\n          hpf(page.trimBox.topRightX) +\n          \" \" +\n          hpf(page.trimBox.topRightY) +\n          \"]\"\n      );\n    }\n\n    if (page.artBox !== null) {\n      out(\n        \"/ArtBox [\" +\n          hpf(page.artBox.bottomLeftX) +\n          \" \" +\n          hpf(page.artBox.bottomLeftY) +\n          \" \" +\n          hpf(page.artBox.topRightX) +\n          \" \" +\n          hpf(page.artBox.topRightY) +\n          \"]\"\n      );\n    }\n\n    if (typeof page.userUnit === \"number\" && page.userUnit !== 1.0) {\n      out(\"/UserUnit \" + page.userUnit);\n    }\n\n    events.publish(\"putPage\", {\n      objId: pageObjectNumber,\n      pageContext: pagesContext[pageNumber],\n      pageNumber: pageNumber,\n      page: data\n    });\n    out(\"/Contents \" + pageContentsObjId + \" 0 R\");\n    out(\">>\");\n    out(\"endobj\");\n    // Page content\n    var pageContent = data.join(\"\\n\");\n\n    if (apiMode === ApiMode.ADVANCED) {\n      // if the user forgot to switch back to COMPAT mode, we must balance the graphics stack again\n      pageContent += \"\\nQ\";\n    }\n\n    newObjectDeferredBegin(pageContentsObjId, true);\n    putStream({\n      data: pageContent,\n      filters: getFilters(),\n      objectId: pageContentsObjId\n    });\n    out(\"endobj\");\n    return pageObjectNumber;\n  });\n\n  var putPages = (API.__private__.putPages = function() {\n    var n,\n      i,\n      pageObjectNumbers = [];\n\n    for (n = 1; n <= page; n++) {\n      pagesContext[n].objId = newObjectDeferred();\n      pagesContext[n].contentsObjId = newObjectDeferred();\n    }\n\n    for (n = 1; n <= page; n++) {\n      pageObjectNumbers.push(\n        putPage({\n          number: n,\n          data: pages[n],\n          objId: pagesContext[n].objId,\n          contentsObjId: pagesContext[n].contentsObjId,\n          mediaBox: pagesContext[n].mediaBox,\n          cropBox: pagesContext[n].cropBox,\n          bleedBox: pagesContext[n].bleedBox,\n          trimBox: pagesContext[n].trimBox,\n          artBox: pagesContext[n].artBox,\n          userUnit: pagesContext[n].userUnit,\n          rootDictionaryObjId: rootDictionaryObjId,\n          resourceDictionaryObjId: resourceDictionaryObjId\n        })\n      );\n    }\n    newObjectDeferredBegin(rootDictionaryObjId, true);\n    out(\"<</Type /Pages\");\n    var kids = \"/Kids [\";\n    for (i = 0; i < page; i++) {\n      kids += pageObjectNumbers[i] + \" 0 R \";\n    }\n    out(kids + \"]\");\n    out(\"/Count \" + page);\n    out(\">>\");\n    out(\"endobj\");\n    events.publish(\"postPutPages\");\n  });\n\n  var putXobjectDict = function() {\n    out(\"/XObject <<\");\n    for (var xObjectKey in renderTargets) {\n      if (\n        renderTargets.hasOwnProperty(xObjectKey) &&\n        renderTargets[xObjectKey].objectNumber >= 0\n      ) {\n        out(\n          \"/\" +\n            xObjectKey +\n            \" \" +\n            renderTargets[xObjectKey].objectNumber +\n            \" 0 R\"\n        );\n      }\n    }\n\n    // Loop through images, or other data objects\n    events.publish(\"putXobjectDict\");\n    out(\">>\");\n  };\n\n  var putResourceDictionary = function(objectIds) {\n    newObjectDeferredBegin(objectIds.resourcesOid, true);\n    out(\"<<\");\n    out(\"/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]\");\n    putXobjectDict();\n    out(\">>\");\n    out(\"endobj\");\n  };\n\n  var putResources = function() {\n    // FormObjects, Patterns etc. might use other FormObjects/Patterns/Images\n    // which means their resource dictionaries must contain the already resolved\n    // object ids. For this reason we defer the serialization of the resource\n    // dicts until all objects have been serialized and have object ids.\n    //\n    // In order to prevent cyclic dependencies (which Adobe Reader doesn't like),\n    // we only put all oids that are smaller than the oid of the object the\n    // resource dict belongs to. This is correct behavior, since the streams\n    // may only use other objects that have already been defined and thus appear\n    // earlier in their respective collection.\n    // Currently, this only affects tiling patterns, but a (more) correct\n    // implementation of FormObjects would also define their own resource dicts.\n    var deferredResourceDictionaryIds = [];\n    events.publish(\"putResources\");\n    deferredResourceDictionaryIds.forEach(putResourceDictionary);\n    putResourceDictionary({\n      resourcesOid: resourceDictionaryObjId,\n      objectOid: Number.MAX_SAFE_INTEGER // output all objects\n    });\n    events.publish(\"postPutResources\");\n  };\n\n  var SAFE = function __safeCall(fn) {\n    fn.foo = function __safeCallWrapper() {\n      try {\n        return fn.apply(this, arguments);\n      } catch (e) {\n        var stack = e.stack || \"\";\n        if (~stack.indexOf(\" at \")) stack = stack.split(\" at \")[1];\n        var m =\n          \"Error in function \" +\n          stack.split(\"\\n\")[0].split(\"<\")[0] +\n          \": \" +\n          e.message;\n        if (globalObject.console) {\n          globalObject.console.error(m, e);\n          if (globalObject.alert) alert(m);\n        } else {\n          throw new Error(m);\n        }\n      }\n    };\n    fn.foo.bar = fn;\n    return fn.foo;\n  };\n\n  var to8bitStream = function(text, flags) {\n    /**\n     * PDF 1.3 spec:\n     * \"For text strings encoded in Unicode, the first two bytes must be 254 followed by\n     * 255, representing the Unicode byte order marker, U+FEFF. (This sequence conflicts\n     * with the PDFDocEncoding character sequence thorn ydieresis, which is unlikely\n     * to be a meaningful beginning of a word or phrase.) The remainder of the\n     * string consists of Unicode character codes, according to the UTF-16 encoding\n     * specified in the Unicode standard, version 2.0. Commonly used Unicode values\n     * are represented as 2 bytes per character, with the high-order byte appearing first\n     * in the string.\"\n     *\n     * In other words, if there are chars in a string with char code above 255, we\n     * recode the string to UCS2 BE - string doubles in length and BOM is prepended.\n     *\n     * HOWEVER!\n     * Actual *content* (body) text (as opposed to strings used in document properties etc)\n     * does NOT expect BOM. There, it is treated as a literal GID (Glyph ID)\n     *\n     * Because of Adobe's focus on \"you subset your fonts!\" you are not supposed to have\n     * a font that maps directly Unicode (UCS2 / UTF16BE) code to font GID, but you could\n     * fudge it with \"Identity-H\" encoding and custom CIDtoGID map that mimics Unicode\n     * code page. There, however, all characters in the stream are treated as GIDs,\n     * including BOM, which is the reason we need to skip BOM in content text (i.e. that\n     * that is tied to a font).\n     *\n     * To signal this \"special\" PDFEscape / to8bitStream handling mode,\n     * API.text() function sets (unless you overwrite it with manual values\n     * given to API.text(.., flags) )\n     * flags.autoencode = true\n     * flags.noBOM = true\n     *\n     * ===================================================================================\n     * `flags` properties relied upon:\n     *   .sourceEncoding = string with encoding label.\n     *                     \"Unicode\" by default. = encoding of the incoming text.\n     *                     pass some non-existing encoding name\n     *                     (ex: 'Do not touch my strings! I know what I am doing.')\n     *                     to make encoding code skip the encoding step.\n     *   .outputEncoding = Either valid PDF encoding name\n     *                     (must be supported by jsPDF font metrics, otherwise no encoding)\n     *                     or a JS object, where key = sourceCharCode, value = outputCharCode\n     *                     missing keys will be treated as: sourceCharCode === outputCharCode\n     *   .noBOM\n     *       See comment higher above for explanation for why this is important\n     *   .autoencode\n     *       See comment higher above for explanation for why this is important\n     */\n\n    var i,\n      l,\n      sourceEncoding,\n      encodingBlock,\n      outputEncoding,\n      newtext,\n      isUnicode,\n      ch,\n      bch;\n\n    flags = flags || {};\n    sourceEncoding = flags.sourceEncoding || \"Unicode\";\n    outputEncoding = flags.outputEncoding;\n\n    // This 'encoding' section relies on font metrics format\n    // attached to font objects by, among others,\n    // \"Willow Systems' standard_font_metrics plugin\"\n    // see jspdf.plugin.standard_font_metrics.js for format\n    // of the font.metadata.encoding Object.\n    // It should be something like\n    //   .encoding = {'codePages':['WinANSI....'], 'WinANSI...':{code:code, ...}}\n    //   .widths = {0:width, code:width, ..., 'fof':divisor}\n    //   .kerning = {code:{previous_char_code:shift, ..., 'fof':-divisor},...}\n    if (\n      (flags.autoencode || outputEncoding) &&\n      fonts[activeFontKey].metadata &&\n      fonts[activeFontKey].metadata[sourceEncoding] &&\n      fonts[activeFontKey].metadata[sourceEncoding].encoding\n    ) {\n      encodingBlock = fonts[activeFontKey].metadata[sourceEncoding].encoding;\n\n      // each font has default encoding. Some have it clearly defined.\n      if (!outputEncoding && fonts[activeFontKey].encoding) {\n        outputEncoding = fonts[activeFontKey].encoding;\n      }\n\n      // Hmmm, the above did not work? Let's try again, in different place.\n      if (!outputEncoding && encodingBlock.codePages) {\n        outputEncoding = encodingBlock.codePages[0]; // let's say, first one is the default\n      }\n\n      if (typeof outputEncoding === \"string\") {\n        outputEncoding = encodingBlock[outputEncoding];\n      }\n      // we want output encoding to be a JS Object, where\n      // key = sourceEncoding's character code and\n      // value = outputEncoding's character code.\n      if (outputEncoding) {\n        isUnicode = false;\n        newtext = [];\n        for (i = 0, l = text.length; i < l; i++) {\n          ch = outputEncoding[text.charCodeAt(i)];\n          if (ch) {\n            newtext.push(String.fromCharCode(ch));\n          } else {\n            newtext.push(text[i]);\n          }\n\n          // since we are looping over chars anyway, might as well\n          // check for residual unicodeness\n          if (newtext[i].charCodeAt(0) >> 8) {\n            /* more than 255 */\n            isUnicode = true;\n          }\n        }\n        text = newtext.join(\"\");\n      }\n    }\n\n    i = text.length;\n    // isUnicode may be set to false above. Hence the triple-equal to undefined\n    while (isUnicode === undefined && i !== 0) {\n      if (text.charCodeAt(i - 1) >> 8) {\n        /* more than 255 */\n        isUnicode = true;\n      }\n      i--;\n    }\n    if (!isUnicode) {\n      return text;\n    }\n\n    newtext = flags.noBOM ? [] : [254, 255];\n    for (i = 0, l = text.length; i < l; i++) {\n      ch = text.charCodeAt(i);\n      bch = ch >> 8; // divide by 256\n      if (bch >> 8) {\n        /* something left after dividing by 256 second time */\n        throw new Error(\n          \"Character at position \" +\n            i +\n            \" of string '\" +\n            text +\n            \"' exceeds 16bits. Cannot be encoded into UCS-2 BE\"\n        );\n      }\n      newtext.push(bch);\n      newtext.push(ch - (bch << 8));\n    }\n    return String.fromCharCode.apply(undefined, newtext);\n  };\n\n  var pdfEscape = (API.__private__.pdfEscape = API.pdfEscape = function(\n    text,\n    flags\n  ) {\n    /**\n     * Replace '/', '(', and ')' with pdf-safe versions\n     *\n     * Doing to8bitStream does NOT make this PDF display unicode text. For that\n     * we also need to reference a unicode font and embed it - royal pain in the rear.\n     *\n     * There is still a benefit to to8bitStream - PDF simply cannot handle 16bit chars,\n     * which JavaScript Strings are happy to provide. So, while we still cannot display\n     * 2-byte characters property, at least CONDITIONALLY converting (entire string containing)\n     * 16bit chars to (USC-2-BE) 2-bytes per char + BOM streams we ensure that entire PDF\n     * is still parseable.\n     * This will allow immediate support for unicode in document properties strings.\n     */\n    return to8bitStream(text, flags)\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\(/g, \"\\\\(\")\n      .replace(/\\)/g, \"\\\\)\");\n  });\n\n  var beginPage = (API.__private__.beginPage = function(format) {\n    pages[++page] = [];\n    pagesContext[page] = {\n      objId: 0,\n      contentsObjId: 0,\n      userUnit: Number(userUnit),\n      artBox: null,\n      bleedBox: null,\n      cropBox: null,\n      trimBox: null,\n      mediaBox: {\n        bottomLeftX: 0,\n        bottomLeftY: 0,\n        topRightX: Number(format[0]),\n        topRightY: Number(format[1])\n      }\n    };\n    _setPage(page);\n    setOutputDestination(pages[currentPage]);\n  });\n\n  var _addPage = function(parmFormat) {\n    var width, height;\n\n    if (Array.isArray(parmFormat)) {\n      width = parmFormat[0] * scaleFactor;\n      height = parmFormat[1] * scaleFactor;\n    }\n\n    if (isNaN(width)) {\n      width = format[0];\n      height = format[1];\n    }\n\n    if (width > 14400 || height > 14400) {\n      console.warn(\n        \"A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400\"\n      );\n      width = Math.min(14400, width);\n      height = Math.min(14400, height);\n    }\n\n    format = [width, height];\n\n    switch (orientation.substr(0, 1)) {\n      case \"l\":\n        if (height > width) {\n          format = [height, width];\n        }\n        break;\n      case \"p\":\n        if (width > height) {\n          format = [height, width];\n        }\n        break;\n    }\n\n    beginPage(format);\n    events.publish(\"addPage\", {\n      pageNumber: page\n    });\n  };\n\n  var _setPage = function(n) {\n    if (n > 0 && n <= page) {\n      currentPage = n;\n    }\n  };\n\n  var getNumberOfPages = (API.__private__.getNumberOfPages = API.getNumberOfPages = function() {\n    return pages.length - 1;\n  });\n\n  var putInfo = (API.__private__.putInfo = function() {\n    out(\"<<\");\n    out(\"/Producer (\" + pdfEscape(\"jsPDF \" + jsPDF.version) + \")\");\n    for (var key in documentProperties) {\n      if (documentProperties.hasOwnProperty(key) && documentProperties[key]) {\n        out(\n          \"/\" +\n            key.substr(0, 1).toUpperCase() +\n            key.substr(1) +\n            \" (\" +\n            pdfEscape(documentProperties[key]) +\n            \")\"\n        );\n      }\n    }\n    out(\"/CreationDate (\" + pdfEscape(creationDate) + \")\");\n    out(\">>\");\n    out(\"endobj\");\n  });\n\n  var putCatalog = (API.__private__.putCatalog = function(options) {\n    options = options || {};\n    var tmpRootDictionaryObjId =\n      options.rootDictionaryObjId || rootDictionaryObjId;\n    newObject();\n    out(\"<<\");\n    out(\"/Type /Catalog\");\n    out(\"/Pages \" + tmpRootDictionaryObjId + \" 0 R\");\n    // PDF13ref Section 7.2.1\n    if (!layoutMode) layoutMode = \"continuous\";\n    switch (layoutMode) {\n      case \"continuous\":\n        out(\"/PageLayout /OneColumn\");\n        break;\n      case \"single\":\n        out(\"/PageLayout /SinglePage\");\n        break;\n      case \"two\":\n      case \"twoleft\":\n        out(\"/PageLayout /TwoColumnLeft\");\n        break;\n      case \"tworight\":\n        out(\"/PageLayout /TwoColumnRight\");\n        break;\n    }\n    if (pageMode) {\n      /**\n       * A name object specifying how the document should be displayed when opened:\n       * UseNone      : Neither document outline nor thumbnail images visible -- DEFAULT\n       * UseOutlines  : Document outline visible\n       * UseThumbs    : Thumbnail images visible\n       * FullScreen   : Full-screen mode, with no menu bar, window controls, or any other window visible\n       */\n      out(\"/PageMode /\" + pageMode);\n    }\n    events.publish(\"putCatalog\");\n    out(\">>\");\n    out(\"endobj\");\n  });\n\n  var putTrailer = (API.__private__.putTrailer = function() {\n    out(\"trailer\");\n    out(\"<<\");\n    out(\"/Size \" + (objectNumber + 1));\n    // Root and Info must be the last and second last objects written respectively\n    out(\"/Root \" + objectNumber + \" 0 R\");\n    out(\"/Info \" + (objectNumber - 1) + \" 0 R\");\n    out(\"/ID [ <\" + fileId + \"> <\" + fileId + \"> ]\");\n    out(\">>\");\n  });\n\n  var putHeader = (API.__private__.putHeader = function() {\n    out(\"%PDF-\" + pdfVersion);\n    out(\"%\\xBA\\xDF\\xAC\\xE0\");\n  });\n\n  var putXRef = (API.__private__.putXRef = function() {\n    var p = \"0000000000\";\n\n    out(\"xref\");\n    out(\"0 \" + (objectNumber + 1));\n    out(\"0000000000 65535 f \");\n    for (var i = 1; i <= objectNumber; i++) {\n      var offset = offsets[i];\n      if (typeof offset === \"function\") {\n        out((p + offsets[i]()).slice(-10) + \" 00000 n \");\n      } else {\n        if (typeof offsets[i] !== \"undefined\") {\n          out((p + offsets[i]).slice(-10) + \" 00000 n \");\n        } else {\n          out(\"0000000000 00000 n \");\n        }\n      }\n    }\n  });\n\n  var buildDocument = (API.__private__.buildDocument = function() {\n    resetDocument();\n    setOutputDestination(content);\n\n    events.publish(\"buildDocument\");\n\n    putHeader();\n    putPages();\n    putResources();\n    putInfo();\n    putCatalog();\n\n    var offsetOfXRef = contentLength;\n    putXRef();\n    putTrailer();\n    out(\"startxref\");\n    out(\"\" + offsetOfXRef);\n    out(\"%%EOF\");\n\n    setOutputDestination(pages[currentPage]);\n\n    return content.join(\"\\n\");\n  });\n\n  /**\n   * Generates the PDF document.\n   *\n   * If `type` argument is undefined, output is raw body of resulting PDF returned as a string.\n   *\n   * @param {string} type A string identifying one of the possible output types.<br/>\n   *                      Possible values are: <br/>\n   *                          'arraybuffer' -> (ArrayBuffer)<br/>\n   *                          'blob' -> (Blob)<br/>\n   *                          'bloburi'/'bloburl' -> (string)<br/>\n   *                          'datauristring'/'dataurlstring' -> (string)<br/>\n   *                          'datauri'/'dataurl' -> (undefined) -> change location to generated datauristring/dataurlstring<br/>\n   *                          'dataurlnewwindow' -> (window | null | undefined) throws error if global isn't a window object(node)<br/>\n   *                          'pdfobjectnewwindow' -> (window | null) throws error if global isn't a window object(node)<br/>\n   *                          'pdfjsnewwindow' -> (wind | null)\n   * @param {Object|string} options An object providing some additional signalling to PDF generator.<br/>\n   *                                Possible options are 'filename'.<br/>\n   *                                A string can be passed instead of {filename:string} and defaults to 'generated.pdf'\n   * @function\n   * @instance\n   * @returns {string|window|ArrayBuffer|Blob|jsPDF|null|undefined}\n   * @memberof jsPDF#\n   * @name output\n   */\n  var output = (API.output = API.__private__.output = SAFE(function output(\n    type,\n    options\n  ) {\n    options = options || {};\n\n    if (typeof options === \"string\") {\n      options = {\n        filename: options\n      };\n    } else {\n      options.filename = options.filename || \"generated.pdf\";\n    }\n\n    switch (type) {\n      case \"arraybuffer\":\n        return getArrayBuffer(buildDocument());\n      case \"datauristring\":\n      case \"dataurlstring\":\n        var dataURI = \"\";\n        var pdfDocument = buildDocument();\n        try {\n          dataURI = btoa(pdfDocument);\n        } catch (e) {\n          dataURI = btoa(unescape(encodeURIComponent(pdfDocument)));\n        }\n        return (\n          \"data:application/pdf;filename=\" +\n          options.filename +\n          \";base64,\" +\n          dataURI\n        );\n      default:\n        return null;\n    }\n  }));\n\n  /**\n   * Used to see if a supplied hotfix was requested when the pdf instance was created.\n   * @param {string} hotfixName - The name of the hotfix to check.\n   * @returns {boolean}\n   */\n  var hasHotfix = function(hotfixName) {\n    return (\n      Array.isArray(hotfixes) === true && hotfixes.indexOf(hotfixName) > -1\n    );\n  };\n\n  switch (unit) {\n    case \"pt\":\n      scaleFactor = 1;\n      break;\n    case \"mm\":\n      scaleFactor = 72 / 25.4;\n      break;\n    case \"cm\":\n      scaleFactor = 72 / 2.54;\n      break;\n    case \"in\":\n      scaleFactor = 72;\n      break;\n    case \"px\":\n      if (hasHotfix(\"px_scaling\") == true) {\n        scaleFactor = 72 / 96;\n      } else {\n        scaleFactor = 96 / 72;\n      }\n      break;\n    case \"pc\":\n      scaleFactor = 12;\n      break;\n    case \"em\":\n      scaleFactor = 12;\n      break;\n    case \"ex\":\n      scaleFactor = 6;\n      break;\n    default:\n      if (typeof unit === \"number\") {\n        scaleFactor = unit;\n      } else {\n        throw new Error(\"Invalid unit: \" + unit);\n      }\n  }\n\n  setCreationDate();\n  setFileId();\n\n  /**\n   * Adds (and transfers the focus to) new page to the PDF document.\n   * @param format {String/Array} The format of the new page. Can be: <ul><li>a0 - a10</li><li>b0 - b10</li><li>c0 - c10</li><li>dl</li><li>letter</li><li>government-letter</li><li>legal</li><li>junior-legal</li><li>ledger</li><li>tabloid</li><li>credit-card</li></ul><br />\n   * Default is \"a4\". If you want to use your own format just pass instead of one of the above predefined formats the size as an number-array, e.g. [595.28, 841.89]\n   * @param orientation {string} Orientation of the new page. Possible values are \"portrait\" or \"landscape\" (or shortcuts \"p\" (Default), \"l\").\n   * @function\n   * @instance\n   * @returns {jsPDF}\n   *\n   * @memberof jsPDF#\n   * @name addPage\n   */\n  API.addPage = function() {\n    _addPage.apply(this, arguments);\n    return this;\n  };\n\n  var isValidStyle = (API.__private__.isValidStyle = function(style) {\n    var validStyleVariants = [\n      undefined,\n      null,\n      \"S\",\n      \"D\",\n      \"F\",\n      \"DF\",\n      \"FD\",\n      \"f\",\n      \"f*\",\n      \"B\",\n      \"B*\",\n      \"n\"\n    ];\n    var result = false;\n    if (validStyleVariants.indexOf(style) !== -1) {\n      result = true;\n    }\n    return result;\n  });\n\n  /**\n   * Close the current path. The PDF \"h\" operator.\n   * @name close\n   * @function\n   * @instance\n   * @returns {jsPDF}\n   * @memberof jsPDF#\n   */\n  var close = (API.close = function() {\n    out(\"h\");\n    return this;\n  });\n\n  var getHorizontalCoordinate = (API.__private__.getHorizontalCoordinate = function(\n    value\n  ) {\n    return scale(value);\n  });\n\n  var getVerticalCoordinate = (API.__private__.getVerticalCoordinate = function(\n    value\n  ) {\n    if (apiMode === ApiMode.ADVANCED) {\n      return value;\n    } else {\n      var pageHeight =\n        pagesContext[currentPage].mediaBox.topRightY -\n        pagesContext[currentPage].mediaBox.bottomLeftY;\n      return pageHeight - scale(value);\n    }\n  });\n\n  var getHorizontalCoordinateString = (API.__private__.getHorizontalCoordinateString = API.getHorizontalCoordinateString = function(\n    value\n  ) {\n    return hpf(getHorizontalCoordinate(value));\n  });\n\n  var getVerticalCoordinateString = (API.__private__.getVerticalCoordinateString = API.getVerticalCoordinateString = function(\n    value\n  ) {\n    return hpf(getVerticalCoordinate(value));\n  });\n\n  // applying plugins (more methods) ON TOP of built-in API.\n  // this is intentional as we allow plugins to override\n  // built-ins\n  for (var plugin in jsPDF.API) {\n    if (jsPDF.API.hasOwnProperty(plugin)) {\n      if (plugin === \"events\" && jsPDF.API.events.length) {\n        (function(events, newEvents) {\n          // jsPDF.API.events is a JS Array of Arrays\n          // where each Array is a pair of event name, handler\n          // Events were added by plugins to the jsPDF instantiator.\n          // These are always added to the new instance and some ran\n          // during instantiation.\n          var eventname, handler_and_args, i;\n\n          for (i = newEvents.length - 1; i !== -1; i--) {\n            // subscribe takes 3 args: 'topic', function, runonce_flag\n            // if undefined, runonce is false.\n            // users can attach callback directly,\n            // or they can attach an array with [callback, runonce_flag]\n            // that's what the \"apply\" magic is for below.\n            eventname = newEvents[i][0];\n            handler_and_args = newEvents[i][1];\n            events.subscribe.apply(\n              events,\n              [eventname].concat(\n                typeof handler_and_args === \"function\"\n                  ? [handler_and_args]\n                  : handler_and_args\n              )\n            );\n          }\n        })(events, jsPDF.API.events);\n      } else {\n        API[plugin] = jsPDF.API[plugin];\n      }\n    }\n  }\n  /**\n   * Object exposing internal API to plugins\n   * @public\n   * @ignore\n   */\n  API.internal = {\n    pdfEscape: pdfEscape,\n    write: write,\n    getHorizontalCoordinate: getHorizontalCoordinate,\n    getVerticalCoordinate: getVerticalCoordinate,\n    getCoordinateString: getHorizontalCoordinateString,\n    getVerticalCoordinateString: getVerticalCoordinateString,\n    collections: {},\n    newObject: newObject,\n    newAdditionalObject: newAdditionalObject,\n    newObjectDeferred: newObjectDeferred,\n    newObjectDeferredBegin: newObjectDeferredBegin,\n    getFilters: getFilters,\n    putStream: putStream,\n    events: events,\n    scaleFactor: scaleFactor,\n    output: output,\n    getNumberOfPages: getNumberOfPages,\n    pages: pages,\n    out: out,\n    getPDFVersion: getPdfVersion,\n    hasHotfix: hasHotfix //Expose the hasHotfix check so plugins can also check them.\n  };\n\n  activeFontKey = \"F1\";\n  _addPage(format, orientation);\n\n  events.publish(\"initialized\");\n  return API;\n}\n\n/**\n * jsPDF.API is a STATIC property of jsPDF class.\n * jsPDF.API is an object you can add methods and properties to.\n * The methods / properties you add will show up in new jsPDF objects.\n *\n * One property is prepopulated. It is the 'events' Object. Plugin authors can add topics,\n * callbacks to this object. These will be reassigned to all new instances of jsPDF.\n *\n * @static\n * @public\n * @memberof jsPDF#\n * @name API\n *\n * @example\n * jsPDF.API.mymethod = function(){\n *   // 'this' will be ref to internal API object. see jsPDF source\n *   // , so you can refer to built-in methods like so:\n *   //     this.line(....)\n *   //     this.text(....)\n * }\n * var pdfdoc = new jsPDF()\n * pdfdoc.mymethod() // <- !!!!!!\n */\njsPDF.API = {\n  events: []\n};\n/**\n * The version of jsPDF.\n * @name version\n * @type {string}\n * @memberof jsPDF#\n */\njsPDF.version = \"0.0.0\";\n\nexport { jsPDF };\nexport default jsPDF;\n","/** @license\n * jsPDF addImage plugin\n * Copyright (c) 2012 Jason Siefken, https://github.com/siefkenj/\n *               2013 Chris Dowling, https://github.com/gingerchris\n *               2013 Trinh Ho, https://github.com/ineedfat\n *               2013 Edwin Alejandro Perez, https://github.com/eaparango\n *               2013 Norah Smith, https://github.com/burnburnrocket\n *               2014 Diego Casorran, https://github.com/diegocr\n *               2014 James Robb, https://github.com/jamesbrobb\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n/**\n * @name addImage\n * @module\n */\n\nimport { jsPDF } from \"../jspdf.js\";\nimport { atob, btoa } from \"../libs/AtobBtoa.js\";\n\n(function(jsPDFAPI) {\n  \"use strict\";\n\n  var namespace = \"addImage_\";\n  jsPDFAPI.__addimage__ = {};\n\n  // Heuristic selection of a good batch for large array .apply. Not limiting make the call overflow.\n  // With too small batch iteration will be slow as more calls are made,\n  // higher values cause larger and slower garbage collection.\n  var ARRAY_APPLY_BATCH = 8192;\n  // Image functionality ported from pdf.js\n  var putImage = function(image) {\n    var out = this.internal.write;\n    var putStream = this.internal.putStream;\n    var getFilters = this.internal.getFilters;\n\n    var filter = getFilters();\n    while (filter.indexOf(\"FlateEncode\") !== -1) {\n      filter.splice(filter.indexOf(\"FlateEncode\"), 1);\n    }\n\n    image.objectId = this.internal.newObject();\n\n    var additionalKeyValues = [];\n    additionalKeyValues.push({ key: \"Type\", value: \"/XObject\" });\n    additionalKeyValues.push({ key: \"Subtype\", value: \"/Image\" });\n    additionalKeyValues.push({ key: \"Width\", value: image.width });\n    additionalKeyValues.push({ key: \"Height\", value: image.height });\n\n    if (image.colorSpace === color_spaces.INDEXED) {\n      additionalKeyValues.push({\n        key: \"ColorSpace\",\n        value:\n          \"[/Indexed /DeviceRGB \" +\n          // if an indexed png defines more than one colour with transparency, we've created a sMask\n          (image.palette.length / 3 - 1) +\n          \" \" +\n          (\"sMask\" in image && typeof image.sMask !== \"undefined\"\n            ? image.objectId + 2\n            : image.objectId + 1) +\n          \" 0 R]\"\n      });\n    } else {\n      additionalKeyValues.push({\n        key: \"ColorSpace\",\n        value: \"/\" + image.colorSpace\n      });\n      if (image.colorSpace === color_spaces.DEVICE_CMYK) {\n        additionalKeyValues.push({ key: \"Decode\", value: \"[1 0 1 0 1 0 1 0]\" });\n      }\n    }\n    additionalKeyValues.push({\n      key: \"BitsPerComponent\",\n      value: image.bitsPerComponent\n    });\n    if (\n      \"decodeParameters\" in image &&\n      typeof image.decodeParameters !== \"undefined\"\n    ) {\n      additionalKeyValues.push({\n        key: \"DecodeParms\",\n        value: \"<<\" + image.decodeParameters + \">>\"\n      });\n    }\n    if (\"transparency\" in image && Array.isArray(image.transparency)) {\n      var transparency = \"\",\n        i = 0,\n        len = image.transparency.length;\n      for (; i < len; i++)\n        transparency +=\n          image.transparency[i] + \" \" + image.transparency[i] + \" \";\n\n      additionalKeyValues.push({\n        key: \"Mask\",\n        value: \"[\" + transparency + \"]\"\n      });\n    }\n    if (typeof image.sMask !== \"undefined\") {\n      additionalKeyValues.push({\n        key: \"SMask\",\n        value: image.objectId + 1 + \" 0 R\"\n      });\n    }\n\n    var alreadyAppliedFilters =\n      typeof image.filter !== \"undefined\" ? [\"/\" + image.filter] : undefined;\n\n    putStream({\n      data: image.data,\n      additionalKeyValues: additionalKeyValues,\n      alreadyAppliedFilters: alreadyAppliedFilters,\n      objectId: image.objectId\n    });\n\n    out(\"endobj\");\n\n    // Soft mask\n    if (\"sMask\" in image && typeof image.sMask !== \"undefined\") {\n      var decodeParameters =\n        \"/Predictor \" +\n        image.predictor +\n        \" /Colors 1 /BitsPerComponent \" +\n        image.bitsPerComponent +\n        \" /Columns \" +\n        image.width;\n      var sMask = {\n        width: image.width,\n        height: image.height,\n        colorSpace: \"DeviceGray\",\n        bitsPerComponent: image.bitsPerComponent,\n        decodeParameters: decodeParameters,\n        data: image.sMask\n      };\n      if (\"filter\" in image) {\n        sMask.filter = image.filter;\n      }\n      putImage.call(this, sMask);\n    }\n\n    //Palette\n    if (image.colorSpace === color_spaces.INDEXED) {\n      var objId = this.internal.newObject();\n      //out('<< /Filter / ' + img['f'] +' /Length ' + img['pal'].length + '>>');\n      //putStream(zlib.compress(img['pal']));\n      putStream({\n        data: arrayBufferToBinaryString(new Uint8Array(image.palette)),\n        objectId: objId\n      });\n      out(\"endobj\");\n    }\n  };\n  var putResourcesCallback = function() {\n    var images = this.internal.collections[namespace + \"images\"];\n    for (var i in images) {\n      putImage.call(this, images[i]);\n    }\n  };\n  var putXObjectsDictCallback = function() {\n    var images = this.internal.collections[namespace + \"images\"],\n      out = this.internal.write,\n      image;\n    for (var i in images) {\n      image = images[i];\n      out(\"/I\" + image.index, image.objectId, \"0\", \"R\");\n    }\n  };\n\n  var checkCompressValue = function(value) {\n    if (value && typeof value === \"string\") value = value.toUpperCase();\n    return value in jsPDFAPI.image_compression ? value : image_compression.NONE;\n  };\n\n  var initialize = function() {\n    if (!this.internal.collections[namespace + \"images\"]) {\n      this.internal.collections[namespace + \"images\"] = {};\n      this.internal.events.subscribe(\"putResources\", putResourcesCallback);\n      this.internal.events.subscribe(\"putXobjectDict\", putXObjectsDictCallback);\n    }\n  };\n\n  var getImages = function() {\n    var images = this.internal.collections[namespace + \"images\"];\n    initialize.call(this);\n    return images;\n  };\n  var getImageIndex = function() {\n    return Object.keys(this.internal.collections[namespace + \"images\"]).length;\n  };\n  var notDefined = function(value) {\n    return typeof value === \"undefined\" || value === null || value.length === 0;\n  };\n  var generateAliasFromImageData = function(imageData) {\n    if (typeof imageData === \"string\" || isArrayBufferView(imageData)) {\n      return sHashCode(imageData);\n    } else if (isArrayBufferView(imageData.data)) {\n      return sHashCode(imageData.data);\n    }\n\n    return null;\n  };\n\n  var isImageTypeSupported = function(type) {\n    return typeof jsPDFAPI[\"process\" + type.toUpperCase()] === \"function\";\n  };\n\n  var checkImagesForAlias = function(alias) {\n    var images = this.internal.collections[namespace + \"images\"];\n    if (images) {\n      for (var e in images) {\n        if (alias === images[e].alias) {\n          return images[e];\n        }\n      }\n    }\n  };\n\n  var determineWidthAndHeight = function(width, height, image) {\n    if (!width && !height) {\n      width = -96;\n      height = -96;\n    }\n    if (width < 0) {\n      width = (-1 * image.width * 72) / width / this.internal.scaleFactor;\n    }\n    if (height < 0) {\n      height = (-1 * image.height * 72) / height / this.internal.scaleFactor;\n    }\n    if (width === 0) {\n      width = (height * image.width) / image.height;\n    }\n    if (height === 0) {\n      height = (width * image.height) / image.width;\n    }\n\n    return [width, height];\n  };\n\n  var writeImageToPDF = function(x, y, width, height, image, rotation) {\n    var dims = determineWidthAndHeight.call(this, width, height, image),\n      coord = this.internal.getCoordinateString,\n      vcoord = this.internal.getVerticalCoordinateString;\n\n    var images = getImages.call(this);\n\n    width = dims[0];\n    height = dims[1];\n    images[image.index] = image;\n\n    if (rotation) {\n      rotation *= Math.PI / 180;\n      var c = Math.cos(rotation);\n      var s = Math.sin(rotation);\n      //like in pdf Reference do it 4 digits instead of 2\n      var f4 = function(number) {\n        return number.toFixed(4);\n      };\n      var rotationTransformationMatrix = [\n        f4(c),\n        f4(s),\n        f4(s * -1),\n        f4(c),\n        0,\n        0,\n        \"cm\"\n      ];\n    }\n    this.internal.write(\"q\"); //Save graphics state\n    if (rotation) {\n      this.internal.write(\n        [1, \"0\", \"0\", 1, coord(x), vcoord(y + height), \"cm\"].join(\" \")\n      ); //Translate\n      this.internal.write(rotationTransformationMatrix.join(\" \")); //Rotate\n      this.internal.write(\n        [coord(width), \"0\", \"0\", coord(height), \"0\", \"0\", \"cm\"].join(\" \")\n      ); //Scale\n    } else {\n      this.internal.write(\n        [\n          coord(width),\n          \"0\",\n          \"0\",\n          coord(height),\n          coord(x),\n          vcoord(y + height),\n          \"cm\"\n        ].join(\" \")\n      ); //Translate and Scale\n    }\n\n    if (this.isAdvancedAPI()) {\n      // draw image bottom up when in \"advanced\" API mode\n      this.internal.write([1, 0, 0, -1, 0, 0, \"cm\"].join(\" \"));\n    }\n\n    this.internal.write(\"/I\" + image.index + \" Do\"); //Paint Image\n    this.internal.write(\"Q\"); //Restore graphics state\n  };\n\n  /**\n   * COLOR SPACES\n   */\n  var color_spaces = (jsPDFAPI.color_spaces = {\n    DEVICE_RGB: \"DeviceRGB\",\n    DEVICE_GRAY: \"DeviceGray\",\n    DEVICE_CMYK: \"DeviceCMYK\",\n    CAL_GREY: \"CalGray\",\n    CAL_RGB: \"CalRGB\",\n    LAB: \"Lab\",\n    ICC_BASED: \"ICCBased\",\n    INDEXED: \"Indexed\",\n    PATTERN: \"Pattern\",\n    SEPARATION: \"Separation\",\n    DEVICE_N: \"DeviceN\"\n  });\n\n  /**\n   * DECODE METHODS\n   */\n  jsPDFAPI.decode = {\n    DCT_DECODE: \"DCTDecode\",\n    FLATE_DECODE: \"FlateDecode\",\n    LZW_DECODE: \"LZWDecode\",\n    JPX_DECODE: \"JPXDecode\",\n    JBIG2_DECODE: \"JBIG2Decode\",\n    ASCII85_DECODE: \"ASCII85Decode\",\n    ASCII_HEX_DECODE: \"ASCIIHexDecode\",\n    RUN_LENGTH_DECODE: \"RunLengthDecode\",\n    CCITT_FAX_DECODE: \"CCITTFaxDecode\"\n  };\n\n  /**\n   * IMAGE COMPRESSION TYPES\n   */\n  var image_compression = (jsPDFAPI.image_compression = {\n    NONE: \"NONE\",\n    FAST: \"FAST\",\n    MEDIUM: \"MEDIUM\",\n    SLOW: \"SLOW\"\n  });\n\n  /**\n   * @name sHashCode\n   * @function\n   * @param {string} data\n   * @returns {string}\n   */\n  var sHashCode = (jsPDFAPI.__addimage__.sHashCode = function(data) {\n    var hash = 0,\n      i,\n      len;\n\n    if (typeof data === \"string\") {\n      len = data.length;\n      for (i = 0; i < len; i++) {\n        hash = (hash << 5) - hash + data.charCodeAt(i);\n        hash |= 0; // Convert to 32bit integer\n      }\n    } else if (isArrayBufferView(data)) {\n      len = data.byteLength / 2;\n      for (i = 0; i < len; i++) {\n        hash = (hash << 5) - hash + data[i];\n        hash |= 0; // Convert to 32bit integer\n      }\n    }\n    return hash;\n  });\n\n  /**\n   * Validates if given String is a valid Base64-String\n   *\n   * @name validateStringAsBase64\n   * @public\n   * @function\n   * @param {String} possible Base64-String\n   *\n   * @returns {boolean}\n   */\n  var validateStringAsBase64 = (jsPDFAPI.__addimage__.validateStringAsBase64 = function(\n    possibleBase64String\n  ) {\n    possibleBase64String = possibleBase64String || \"\";\n    possibleBase64String.toString().trim();\n\n    var result = true;\n\n    if (possibleBase64String.length === 0) {\n      result = false;\n    }\n\n    if (possibleBase64String.length % 4 !== 0) {\n      result = false;\n    }\n\n    if (\n      /^[A-Za-z0-9+/]+$/.test(\n        possibleBase64String.substr(0, possibleBase64String.length - 2)\n      ) === false\n    ) {\n      result = false;\n    }\n\n    if (\n      /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(\n        possibleBase64String.substr(-2)\n      ) === false\n    ) {\n      result = false;\n    }\n    return result;\n  });\n\n  /**\n   * Strips out and returns info from a valid base64 data URI\n   *\n   * @name extractImageFromDataUrl\n   * @function\n   * @param {string} dataUrl a valid data URI of format 'data:[<MIME-type>][;base64],<data>'\n   * @returns {Array}an Array containing the following\n   * [0] the complete data URI\n   * [1] <MIME-type>\n   * [2] format - the second part of the mime-type i.e 'png' in 'image/png'\n   * [4] <data>\n   */\n  var extractImageFromDataUrl = (jsPDFAPI.__addimage__.extractImageFromDataUrl = function(\n    dataUrl\n  ) {\n    dataUrl = dataUrl || \"\";\n    var dataUrlParts = dataUrl.split(\"base64,\");\n    var result = null;\n\n    if (dataUrlParts.length === 2) {\n      var extractedInfo = /^data:(\\w*\\/\\w*);*(charset=(?!charset=)[\\w=-]*)*;*$/.exec(\n        dataUrlParts[0]\n      );\n      if (Array.isArray(extractedInfo)) {\n        result = {\n          mimeType: extractedInfo[1],\n          charset: extractedInfo[2],\n          data: dataUrlParts[1]\n        };\n      }\n    }\n    return result;\n  });\n\n  /**\n   * Check to see if ArrayBuffer is supported\n   *\n   * @name supportsArrayBuffer\n   * @function\n   * @returns {boolean}\n   */\n  var supportsArrayBuffer = (jsPDFAPI.__addimage__.supportsArrayBuffer = function() {\n    return (\n      typeof ArrayBuffer !== \"undefined\" && typeof Uint8Array !== \"undefined\"\n    );\n  });\n\n  /**\n   * Tests supplied object to determine if ArrayBuffer\n   *\n   * @name isArrayBuffer\n   * @function\n   * @param {Object} object an Object\n   *\n   * @returns {boolean}\n   */\n  jsPDFAPI.__addimage__.isArrayBuffer = function(object) {\n    return supportsArrayBuffer() && object instanceof ArrayBuffer;\n  };\n\n  /**\n   * Tests supplied object to determine if it implements the ArrayBufferView (TypedArray) interface\n   *\n   * @name isArrayBufferView\n   * @function\n   * @param {Object} object an Object\n   * @returns {boolean}\n   */\n  var isArrayBufferView = (jsPDFAPI.__addimage__.isArrayBufferView = function(\n    object\n  ) {\n    return (\n      supportsArrayBuffer() &&\n      typeof Uint32Array !== \"undefined\" &&\n      (object instanceof Int8Array ||\n        object instanceof Uint8Array ||\n        (typeof Uint8ClampedArray !== \"undefined\" &&\n          object instanceof Uint8ClampedArray) ||\n        object instanceof Int16Array ||\n        object instanceof Uint16Array ||\n        object instanceof Int32Array ||\n        object instanceof Uint32Array ||\n        object instanceof Float32Array ||\n        object instanceof Float64Array)\n    );\n  });\n\n  /**\n   * Convert Binary String to ArrayBuffer\n   *\n   * @name binaryStringToUint8Array\n   * @public\n   * @function\n   * @param {string} BinaryString with ImageData\n   * @returns {Uint8Array}\n   */\n  var binaryStringToUint8Array = (jsPDFAPI.__addimage__.binaryStringToUint8Array = function(\n    binary_string\n  ) {\n    var len = binary_string.length;\n    var bytes = new Uint8Array(len);\n    for (var i = 0; i < len; i++) {\n      bytes[i] = binary_string.charCodeAt(i);\n    }\n    return bytes;\n  });\n\n  /**\n   * Convert the Buffer to a Binary String\n   *\n   * @name arrayBufferToBinaryString\n   * @public\n   * @function\n   * @param {ArrayBuffer|ArrayBufferView} ArrayBuffer buffer or bufferView with ImageData\n   *\n   * @returns {String}\n   */\n  var arrayBufferToBinaryString = (jsPDFAPI.__addimage__.arrayBufferToBinaryString = function(\n    buffer\n  ) {\n    var out = \"\";\n    // There are calls with both ArrayBuffer and already converted Uint8Array or other BufferView.\n    // Do not copy the array if input is already an array.\n    var buf = isArrayBufferView(buffer) ? buffer : new Uint8Array(buffer);\n    for (var i = 0; i < buf.length; i += ARRAY_APPLY_BATCH) {\n      // Limit the amount of characters being parsed to prevent overflow.\n      // Note that while TextDecoder would be faster, it does not have the same\n      // functionality as fromCharCode with any provided encodings as of 3/2021.\n      out += String.fromCharCode.apply(\n        null,\n        buf.subarray(i, i + ARRAY_APPLY_BATCH)\n      );\n    }\n    return out;\n  });\n\n  /**\n   * Possible parameter for addImage, an RGBA buffer with size.\n   *\n   * @typedef {Object} RGBAData\n   * @property {Uint8ClampedArray} data - Single dimensional array of RGBA values. For example from canvas getImageData.\n   * @property {number} width - Image width as the data does not carry this information in itself.\n   * @property {number} height - Image height as the data does not carry this information in itself.\n   */\n\n  /**\n   * Adds an Image to the PDF.\n   *\n   * @name addImage\n   * @public\n   * @function\n   * @param {string|HTMLImageElement|HTMLCanvasElement|Uint8Array|RGBAData} imageData imageData as base64 encoded DataUrl or Image-HTMLElement or Canvas-HTMLElement or object containing RGBA array (like output from canvas.getImageData).\n   * @param {string} format format of file if filetype-recognition fails or in case of a Canvas-Element needs to be specified (default for Canvas is JPEG), e.g. 'JPEG', 'PNG', 'WEBP'\n   * @param {number} x x Coordinate (in units declared at inception of PDF document) against left edge of the page\n   * @param {number} y y Coordinate (in units declared at inception of PDF document) against upper edge of the page\n   * @param {number} width width of the image (in units declared at inception of PDF document)\n   * @param {number} height height of the Image (in units declared at inception of PDF document)\n   * @param {string} alias alias of the image (if used multiple times)\n   * @param {string} compression compression of the generated JPEG, can have the values 'NONE', 'FAST', 'MEDIUM' and 'SLOW'\n   * @param {number} rotation rotation of the image in degrees (0-359)\n   *\n   * @returns jsPDF\n   */\n  jsPDFAPI.addImage = function() {\n    var imageData, format, x, y, w, h, alias, compression, rotation;\n\n    imageData = arguments[0];\n    format = arguments[1];\n    x = arguments[2];\n    y = arguments[3];\n    w = arguments[4];\n    h = arguments[5];\n    alias = arguments[6];\n    compression = arguments[7];\n    rotation = arguments[8];\n\n    //If compression is not explicitly set, determine if we should use compression\n    var filter = this.internal.getFilters();\n    if (compression === undefined && filter.indexOf(\"FlateEncode\") !== -1) {\n      compression = \"SLOW\";\n    }\n\n    if (isNaN(x) || isNaN(y)) {\n      throw new Error(\"Invalid coordinates passed to jsPDF.addImage\");\n    }\n\n    initialize.call(this);\n\n    var image = processImageData.call(\n      this,\n      imageData,\n      format,\n      alias,\n      compression\n    );\n\n    writeImageToPDF.call(this, x, y, w, h, image, rotation);\n\n    return this;\n  };\n\n  var processImageData = function(imageData, format, alias, compression) {\n    var result, dataAsBinaryString;\n    imageData = unescape(imageData);\n    var tmpImageData = convertBase64ToBinaryString(imageData, false);\n    imageData = tmpImageData;\n\n    format = \"PNG\";\n    if (!isImageTypeSupported(format)) {\n      throw new Error(\n        \"addImage does not support files of type '\" +\n          format +\n          \"', please ensure that a plugin for '\" +\n          format +\n          \"' support is added.\"\n      );\n    }\n\n    // now do the heavy lifting\n\n    if (notDefined(alias)) {\n      alias = generateAliasFromImageData(imageData);\n    }\n    result = checkImagesForAlias.call(this, alias);\n\n    if (!result) {\n      if (supportsArrayBuffer()) {\n        // no need to convert if imageData is already uint8array\n        if (!(imageData instanceof Uint8Array) && format !== \"RGBA\") {\n          dataAsBinaryString = imageData;\n          imageData = binaryStringToUint8Array(imageData);\n        }\n      }\n\n      result = this[\"process\" + format.toUpperCase()](\n        imageData,\n        getImageIndex.call(this),\n        alias,\n        checkCompressValue(compression),\n        dataAsBinaryString\n      );\n    }\n\n    if (!result) {\n      throw new Error(\"An unknown error occurred whilst processing the image.\");\n    }\n    return result;\n  };\n\n  /**\n   * @name convertBase64ToBinaryString\n   * @function\n   * @param {string} stringData\n   * @returns {string} binary string\n   */\n  var convertBase64ToBinaryString = (jsPDFAPI.__addimage__.convertBase64ToBinaryString = function(\n    stringData,\n    throwError\n  ) {\n    throwError = typeof throwError === \"boolean\" ? throwError : true;\n    var base64Info;\n    var imageData = \"\";\n    var rawData;\n\n    if (typeof stringData === \"string\") {\n      base64Info = extractImageFromDataUrl(stringData);\n      rawData = base64Info !== null ? base64Info.data : stringData;\n\n      try {\n        imageData = atob(rawData);\n      } catch (e) {\n        if (throwError) {\n          if (!validateStringAsBase64(rawData)) {\n            throw new Error(\n              \"Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString \"\n            );\n          } else {\n            throw new Error(\n              \"atob-Error in jsPDF.convertBase64ToBinaryString \" + e.message\n            );\n          }\n        }\n      }\n    }\n    return imageData;\n  });\n\n  /**\n   * @name getImageProperties\n   * @function\n   * @param {Object} imageData\n   * @returns {Object}\n   */\n  jsPDFAPI.getImageProperties = function(imageData) {\n    var image;\n    var tmpImageData = \"\";\n    var format = \"PNG\";\n\n    tmpImageData = convertBase64ToBinaryString(imageData, false);\n    imageData = tmpImageData;\n\n    if (!isImageTypeSupported(format)) {\n      throw new Error(\n        \"addImage does not support files of type '\" +\n          format +\n          \"', please ensure that a plugin for '\" +\n          format +\n          \"' support is added.\"\n      );\n    }\n\n    if (supportsArrayBuffer() && !(imageData instanceof Uint8Array)) {\n      imageData = binaryStringToUint8Array(imageData);\n    }\n\n    image = this[\"process\" + format.toUpperCase()](imageData);\n\n    if (!image) {\n      throw new Error(\"An unknown error occurred whilst processing the image\");\n    }\n\n    image.fileType = format;\n\n    return image;\n  };\n})(jsPDF.API);\n","// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Much of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// Many optimizations have been made, so the bundle size is ultimately smaller but performance is similar.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\n// Mediocre shim\nvar Worker;\nvar workerAdd = \";var __w=require('worker_threads');__w.parentPort.on('message',function(m){onmessage({data:m})}),postMessage=function(m,t){__w.parentPort.postMessage(m,t)},close=process.exit;self=global\";\ntry {\n    Worker = require('worker_threads').Worker;\n}\ncatch (e) {\n}\nvar wk = Worker ? function (c, _, msg, transfer, cb) {\n    var done = false;\n    var w = new Worker(c + workerAdd, { eval: true })\n        .on('error', function (e) { return cb(e, null); })\n        .on('message', function (m) { return cb(null, m); })\n        .on('exit', function (c) {\n        if (c && !done)\n            cb(new Error('exited with code ' + c), null);\n    });\n    w.postMessage(msg, transfer);\n    w.terminate = function () {\n        done = true;\n        return Worker.prototype.terminate.call(w);\n    };\n    return w;\n} : function (_, __, ___, ____, cb) {\n    setImmediate(function () { return cb(new Error('async operations unsupported - update to Node 12+ (or Node 10-11 with the --experimental-worker CLI flag)'), null); });\n    var NOP = function () { };\n    return {\n        terminate: NOP,\n        postMessage: NOP\n    };\n};\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return [b, r];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i)\n        ++l[cd[i] - 1];\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 0; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i)\n            co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) >> 0;\n    return ((d[o] | (d[o + 1] << 8)) >>> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) >> 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >>> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p / 8) >> 0) + (p & 7 && 1); };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st)\n        st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            st.f = final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        throw 'unexpected EOF';\n                    break;\n                }\n                // ensure size\n                if (noBuf)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                if (!noSt && pos + tl * (clb + 7) > tbts)\n                    break;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                throw 'invalid block type';\n            if (pos > tbts)\n                throw 'unexpected EOF';\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var mxa = lbt + dbt + 18;\n        while (noSt || pos + mxa < tbts) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts)\n                throw 'unexpected EOF';\n            if (!c)\n                throw 'invalid length/literal';\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d)\n                    throw 'invalid distance';\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n                }\n                if (pos > tbts)\n                    throw 'unexpected EOF';\n                if (noBuf)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                for (; bt < end; bt += 4) {\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = pos, st.b = bt;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) >> 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) >> 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return [new u8(0), 0];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [v, 1];\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [new u8(tr), mbt];\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [cl.subarray(0, cli), s];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        lcfreq[lclt[i] & 31]++;\n    for (var i = 0; i < lcdt.length; ++i)\n        lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        if (syms[i] > 255) {\n            var len = (syms[i] >>> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.floor(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for (var i = 0; i <= s; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e < s) {\n                // write full block\n                pos = wfblk(w, pos, dat.subarray(i, e));\n            }\n            else {\n                // write final block\n                w[i] = lst;\n                pos = wfblk(w, pos, dat.subarray(i, s));\n            }\n        }\n    }\n    else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for (; i < s; ++i) {\n            // hash value\n            var hv = hsh(i);\n            // index mod 32768\n            var imod = i & 32767;\n            // previous index with this value\n            var pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = (i - dif + j + 32768) & 32767;\n                                    var pti = prev[ti];\n                                    var cd = (ti - pti + 32768) & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += (imod - pimod + 32768) & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst)\n            pos = wfblk(w, pos, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new u32(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && 0xEDB88320) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = 0xFFFFFFFF;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return c ^ 0xFFFFFFFF; }\n    };\n};\n// Alder32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 5552, l);\n                for (; i < e; ++i)\n                    n += d[i], m += n;\n                n %= 65521, m %= 65521;\n            }\n            a = n, b = m;\n        },\n        d: function () { return ((a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8)) + ((a & 255) << 23) * 2; }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/ /g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return [fnStr, td];\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32)\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            _a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, hMap, max, bits, bits16, shft, slc, inflt, inflateSync, pbf, gu8]; };\nvar bDflt = function () { return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zlv]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get u8\nvar gu8 = function (o) { return o && o.size && new u8(o.size); };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    if (!opts.consume)\n        dat = new u8(dat);\n    w.postMessage([dat, opts], [dat.buffer]);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) { return strm.push(ev.data[0], ev.data[1]); };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function (d, f) {\n        if (t)\n            throw 'stream finished';\n        if (!strm.ondata)\n            throw 'no stream handler';\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16)) + (d[b + 3] << 23) * 2; };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        throw 'invalid gzip data';\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += d[10] | (d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) + (2 * (d[l - 1] << 23));\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + ((o.filename && (o.filename.length + 1)) || 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);\n};\n// zlib valid\nvar zlv = function (d) {\n    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        throw 'invalid zlib data';\n    if (d[1] & 32)\n        throw 'invalid zlib data: preset dictionaries not supported';\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    if (opts === void 0) { opts = {}; }\n    return dopt(data, opts, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function (c) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function (final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) >> 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, 0, function () {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gu8(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, out) {\n    return inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (opts === void 0) { opts = {}; }\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = gzs(this.p);\n            if (s >= this.p.length && !final)\n                return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8)\n                throw 'invalid gzip stream';\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, 0, function () {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (opts === void 0) { opts = {}; }\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final)\n                return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                throw 'invalid zlib stream';\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, 0, function () {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gu8(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */\n    function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no stream handler';\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function () { _this_1.ondata.apply(_this_1, arguments); };\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(cb)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(cb)\n                        : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */\n    function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, out) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, out)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, out)\n            : unzlibSync(data, out);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k;\n        if (val instanceof u8)\n            t[n] = [val, o];\n        else if (Array.isArray(val))\n            t[n] = [val[0], mrg(o, val[1])];\n        else\n            fltn(val, n + '/', t, o);\n    }\n};\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    var l = str.length;\n    if (!latin1 && typeof TextEncoder != 'undefined')\n        return new TextEncoder().encode(str);\n    var ar = new u8(str.length + (str.length >>> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >>> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >>> 18)), w(128 | ((c >>> 12) & 63)), w(128 | ((c >>> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >>> 12)), w(128 | ((c >>> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    var r = '';\n    if (!latin1 && typeof TextDecoder != 'undefined')\n        return new TextDecoder().decode(dat);\n    for (var i = 0; i < dat.length;) {\n        var c = dat[i++];\n        if (c < 128 || latin1)\n            r += String.fromCharCode(c);\n        else if (c < 224)\n            r += String.fromCharCode((c & 31) << 6 | (dat[i++] & 63));\n        else if (c < 240)\n            r += String.fromCharCode((c & 15) << 12 | (dat[i++] & 63) << 6 | (dat[i++] & 63));\n        else\n            c = ((c & 15) << 18 | (dat[i++] & 63) << 12 | (dat[i++] & 63) << 6 | (dat[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n    }\n    return r;\n}\n;\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl;\n    var _a = z ? z64e(d, es) : [b4(d, b + 20), b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b4(d, b + 12), b4(d, b + 4), b4(d, b + 20)];\n};\n// write zip header\nvar wzh = function (d, b, c, cmp, su, fn, u, o, ce, t) {\n    var fl = fn.length, l = cmp.length;\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b] = 20, b += 2;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (t == 8 && (o.level == 1 ? 6 : o.level < 6 ? 4 : o.level == 9 ? 2 : 0)), d[b++] = u && 8;\n    d[b] = t, b += 2;\n    var dt = new Date(o.mtime || Date.now()), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        throw 'date not in range 1980-2099';\n    wbytes(d, b, ((y << 24) * 2) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1));\n    b += 4;\n    wbytes(d, b, c);\n    wbytes(d, b + 4, l);\n    wbytes(d, b + 8, su);\n    wbytes(d, b + 12, fl), b += 16; // skip extra field, comment\n    if (ce != null)\n        wbytes(d, b += 10, ce), b += 4;\n    d.set(fn, b);\n    b += fl;\n    if (ce == null)\n        d.set(cmp, b);\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                wzh(out, tot, f.c, f.d, f.m, f.n, f.u, f.p, null, f.t);\n                wzh(out, o, f.c, f.d, f.m, f.n, f.u, f.p, tot, f.t), o += 46 + f.n.length, tot += 30 + f.n.length + f.d.length;\n            }\n            catch (e) {\n                return cb(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cb(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), m = file.length;\n        c.p(file);\n        var n = strToU8(fn), s = n.length;\n        var t = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = {\n                    t: t,\n                    d: d,\n                    m: m,\n                    c: c.d(),\n                    u: fn.length != l,\n                    n: n,\n                    p: p\n                };\n                o += 30 + s + l;\n                tot += 76 + 2 * s + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (n.length > 65535)\n            cbl('filename too long', null);\n        if (!t)\n            cbl(null, file);\n        else if (m < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (opts === void 0) { opts = {}; }\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var t = p.level == 0 ? 0 : 8;\n        var n = strToU8(fn), s = n.length;\n        if (n.length > 65535)\n            throw 'filename too long';\n        var d = t ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push({\n            t: t,\n            d: d,\n            m: file.length,\n            c: c.d(),\n            u: fn.length != s,\n            n: n,\n            o: o,\n            p: p\n        });\n        o += 30 + s + l;\n        tot += 76 + 2 * s + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f.c, f.d, f.m, f.n, f.u, f.p, null, f.t);\n        wzh(out, o, f.c, f.d, f.m, f.n, f.u, f.p, f.o, f.t), o += 46 + f.n.length;\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Asynchronously decompresses a ZIP archive\n * @param data The raw compressed ZIP file\n * @param cb The callback to call with the decompressed files\n * @returns A function that can be used to immediately terminate the unzipping\n */\nexport function unzip(data, cb) {\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cb('invalid zip file', null);\n            return;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (!lft)\n        cb(null, {});\n    var c = lft;\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50)\n            throw 'invalid zip file';\n        c = lft = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    var _loop_2 = function (i) {\n        var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                files[fn] = d;\n                if (!--lft)\n                    cb(null, files);\n            }\n        };\n        if (!c_1)\n            cbl(null, slc(data, b, b + sc));\n        else if (c_1 == 8) {\n            var infl = data.subarray(b, b + sc);\n            if (sc < 320000) {\n                try {\n                    cbl(null, inflateSync(infl, new u8(su)));\n                }\n                catch (e) {\n                    cbl(e, null);\n                }\n            }\n            else\n                term.push(inflate(infl, { size: su }, cbl));\n        }\n        else\n            cbl('unknown compression type ' + c_1, null);\n    };\n    for (var i = 0; i < c; ++i) {\n        _loop_2(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @returns The decompressed files\n */\nexport function unzipSync(data) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            throw 'invalid zip file';\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50)\n            throw 'invalid zip file';\n        c = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!c_2)\n            files[fn] = slc(data, b, b + sc);\n        else if (c_2 == 8)\n            files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n        else\n            throw 'unknown compression type ' + c_2;\n    }\n    return files;\n}\n","// Generated by CoffeeScript 1.4.0\n\n/**\n * @license\n * PNG.js\n * Copyright (c) 2011 Devon Govett\n * MIT LICENSE\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\n * to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or\n * substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport { unzlibSync } from \"./fflate.js\";\nimport { globalObject } from \"./globalObject.js\";\n\nvar PNG = (function() {\n  var APNG_BLEND_OP_OVER,\n    APNG_BLEND_OP_SOURCE,\n    APNG_DISPOSE_OP_BACKGROUND,\n    APNG_DISPOSE_OP_NONE,\n    APNG_DISPOSE_OP_PREVIOUS,\n    makeImage,\n    scratchCanvas,\n    scratchCtx;\n\n  APNG_DISPOSE_OP_NONE = 0;\n\n  APNG_DISPOSE_OP_BACKGROUND = 1;\n\n  APNG_DISPOSE_OP_PREVIOUS = 2;\n\n  APNG_BLEND_OP_SOURCE = 0;\n\n  APNG_BLEND_OP_OVER = 1;\n\n  function PNG(data) {\n    var chunkSize,\n      colors,\n      palLen,\n      delayDen,\n      delayNum,\n      frame,\n      i,\n      index,\n      key,\n      section,\n      palShort,\n      text,\n      _i,\n      _j,\n      _ref;\n    this.data = data;\n    this.pos = 8;\n    this.palette = [];\n    this.imgData = [];\n    this.transparency = {};\n    this.animation = null;\n    this.text = {};\n    frame = null;\n    while (true) {\n      chunkSize = this.readUInt32();\n      section = function() {\n        var _i, _results;\n        _results = [];\n        for (i = _i = 0; _i < 4; i = ++_i) {\n          _results.push(String.fromCharCode(this.data[this.pos++]));\n        }\n        return _results;\n      }\n        .call(this)\n        .join(\"\");\n      switch (section) {\n        case \"IHDR\":\n          this.width = this.readUInt32();\n          this.height = this.readUInt32();\n          this.bits = this.data[this.pos++];\n          this.colorType = this.data[this.pos++];\n          this.compressionMethod = this.data[this.pos++];\n          this.filterMethod = this.data[this.pos++];\n          this.interlaceMethod = this.data[this.pos++];\n          break;\n        case \"acTL\":\n          this.animation = {\n            numFrames: this.readUInt32(),\n            numPlays: this.readUInt32() || Infinity,\n            frames: []\n          };\n          break;\n        case \"PLTE\":\n          this.palette = this.read(chunkSize);\n          break;\n        case \"fcTL\":\n          if (frame) {\n            this.animation.frames.push(frame);\n          }\n          this.pos += 4;\n          frame = {\n            width: this.readUInt32(),\n            height: this.readUInt32(),\n            xOffset: this.readUInt32(),\n            yOffset: this.readUInt32()\n          };\n          delayNum = this.readUInt16();\n          delayDen = this.readUInt16() || 100;\n          frame.delay = (1000 * delayNum) / delayDen;\n          frame.disposeOp = this.data[this.pos++];\n          frame.blendOp = this.data[this.pos++];\n          frame.data = [];\n          break;\n        case \"IDAT\":\n        case \"fdAT\":\n          if (section === \"fdAT\") {\n            this.pos += 4;\n            chunkSize -= 4;\n          }\n          data = (frame != null ? frame.data : void 0) || this.imgData;\n          for (\n            i = _i = 0;\n            0 <= chunkSize ? _i < chunkSize : _i > chunkSize;\n            i = 0 <= chunkSize ? ++_i : --_i\n          ) {\n            data.push(this.data[this.pos++]);\n          }\n          break;\n        case \"tRNS\":\n          this.transparency = {};\n          switch (this.colorType) {\n            case 3:\n              palLen = this.palette.length / 3;\n              this.transparency.indexed = this.read(chunkSize);\n              if (this.transparency.indexed.length > palLen)\n                throw new Error(\"More transparent colors than palette size\");\n              /*\n               * According to the PNG spec trns should be increased to the same size as palette if shorter\n               */\n              //palShort = 255 - this.transparency.indexed.length;\n              palShort = palLen - this.transparency.indexed.length;\n              if (palShort > 0) {\n                for (\n                  i = _j = 0;\n                  0 <= palShort ? _j < palShort : _j > palShort;\n                  i = 0 <= palShort ? ++_j : --_j\n                ) {\n                  this.transparency.indexed.push(255);\n                }\n              }\n              break;\n            case 0:\n              this.transparency.grayscale = this.read(chunkSize)[0];\n              break;\n            case 2:\n              this.transparency.rgb = this.read(chunkSize);\n          }\n          break;\n        case \"tEXt\":\n          text = this.read(chunkSize);\n          index = text.indexOf(0);\n          key = String.fromCharCode.apply(String, text.slice(0, index));\n          this.text[key] = String.fromCharCode.apply(\n            String,\n            text.slice(index + 1)\n          );\n          break;\n        case \"IEND\":\n          if (frame) {\n            this.animation.frames.push(frame);\n          }\n          this.colors = function() {\n            switch (this.colorType) {\n              case 0:\n              case 3:\n              case 4:\n                return 1;\n              case 2:\n              case 6:\n                return 3;\n            }\n          }.call(this);\n          this.hasAlphaChannel = (_ref = this.colorType) === 4 || _ref === 6;\n          colors = this.colors + (this.hasAlphaChannel ? 1 : 0);\n          this.pixelBitlength = this.bits * colors;\n          this.colorSpace = function() {\n            switch (this.colors) {\n              case 1:\n                return \"DeviceGray\";\n              case 3:\n                return \"DeviceRGB\";\n            }\n          }.call(this);\n          this.imgData = new Uint8Array(this.imgData);\n          return;\n        default:\n          this.pos += chunkSize;\n      }\n      this.pos += 4;\n      if (this.pos > this.data.length) {\n        throw new Error(\"Incomplete or corrupt PNG file\");\n      }\n    }\n  }\n\n  PNG.prototype.read = function(bytes) {\n    var i, _i, _results;\n    _results = [];\n    for (\n      i = _i = 0;\n      0 <= bytes ? _i < bytes : _i > bytes;\n      i = 0 <= bytes ? ++_i : --_i\n    ) {\n      _results.push(this.data[this.pos++]);\n    }\n    return _results;\n  };\n\n  PNG.prototype.readUInt32 = function() {\n    var b1, b2, b3, b4;\n    b1 = this.data[this.pos++] << 24;\n    b2 = this.data[this.pos++] << 16;\n    b3 = this.data[this.pos++] << 8;\n    b4 = this.data[this.pos++];\n    return b1 | b2 | b3 | b4;\n  };\n\n  PNG.prototype.readUInt16 = function() {\n    var b1, b2;\n    b1 = this.data[this.pos++] << 8;\n    b2 = this.data[this.pos++];\n    return b1 | b2;\n  };\n\n  PNG.prototype.decodePixels = function(data) {\n    var pixelBytes = this.pixelBitlength / 8;\n    var fullPixels = new Uint8Array(this.width * this.height * pixelBytes);\n    var pos = 0;\n    var _this = this;\n\n    if (data == null) {\n      data = this.imgData;\n    }\n    if (data.length === 0) {\n      return new Uint8Array(0);\n    }\n\n    data = unzlibSync(data);\n    function pass(x0, y0, dx, dy) {\n      var abyte,\n        c,\n        col,\n        i,\n        left,\n        length,\n        p,\n        pa,\n        paeth,\n        pb,\n        pc,\n        pixels,\n        row,\n        scanlineLength,\n        upper,\n        upperLeft,\n        _i,\n        _j,\n        _k,\n        _l,\n        _m;\n      var w = Math.ceil((_this.width - x0) / dx),\n        h = Math.ceil((_this.height - y0) / dy);\n      var isFull = _this.width == w && _this.height == h;\n      scanlineLength = pixelBytes * w;\n      pixels = isFull ? fullPixels : new Uint8Array(scanlineLength * h);\n      length = data.length;\n      row = 0;\n      c = 0;\n      while (row < h && pos < length) {\n        switch (data[pos++]) {\n          case 0:\n            for (i = _i = 0; _i < scanlineLength; i = _i += 1) {\n              pixels[c++] = data[pos++];\n            }\n            break;\n          case 1:\n            for (i = _j = 0; _j < scanlineLength; i = _j += 1) {\n              abyte = data[pos++];\n              left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n              pixels[c++] = (abyte + left) % 256;\n            }\n            break;\n          case 2:\n            for (i = _k = 0; _k < scanlineLength; i = _k += 1) {\n              abyte = data[pos++];\n              col = (i - (i % pixelBytes)) / pixelBytes;\n              upper =\n                row &&\n                pixels[\n                  (row - 1) * scanlineLength +\n                    col * pixelBytes +\n                    (i % pixelBytes)\n                ];\n              pixels[c++] = (upper + abyte) % 256;\n            }\n            break;\n          case 3:\n            for (i = _l = 0; _l < scanlineLength; i = _l += 1) {\n              abyte = data[pos++];\n              col = (i - (i % pixelBytes)) / pixelBytes;\n              left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n              upper =\n                row &&\n                pixels[\n                  (row - 1) * scanlineLength +\n                    col * pixelBytes +\n                    (i % pixelBytes)\n                ];\n              pixels[c++] = (abyte + Math.floor((left + upper) / 2)) % 256;\n            }\n            break;\n          case 4:\n            for (i = _m = 0; _m < scanlineLength; i = _m += 1) {\n              abyte = data[pos++];\n              col = (i - (i % pixelBytes)) / pixelBytes;\n              left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n              if (row === 0) {\n                upper = upperLeft = 0;\n              } else {\n                upper =\n                  pixels[\n                    (row - 1) * scanlineLength +\n                      col * pixelBytes +\n                      (i % pixelBytes)\n                  ];\n                upperLeft =\n                  col &&\n                  pixels[\n                    (row - 1) * scanlineLength +\n                      (col - 1) * pixelBytes +\n                      (i % pixelBytes)\n                  ];\n              }\n              p = left + upper - upperLeft;\n              pa = Math.abs(p - left);\n              pb = Math.abs(p - upper);\n              pc = Math.abs(p - upperLeft);\n              if (pa <= pb && pa <= pc) {\n                paeth = left;\n              } else if (pb <= pc) {\n                paeth = upper;\n              } else {\n                paeth = upperLeft;\n              }\n              pixels[c++] = (abyte + paeth) % 256;\n            }\n            break;\n          default:\n            throw new Error(\"Invalid filter algorithm: \" + data[pos - 1]);\n        }\n        if (!isFull) {\n          var fullPos = ((y0 + row * dy) * _this.width + x0) * pixelBytes;\n          var partPos = row * scanlineLength;\n          for (i = 0; i < w; i += 1) {\n            for (var j = 0; j < pixelBytes; j += 1)\n              fullPixels[fullPos++] = pixels[partPos++];\n            fullPos += (dx - 1) * pixelBytes;\n          }\n        }\n        row++;\n      }\n    }\n    if (_this.interlaceMethod == 1) {\n      /*\n          1 6 4 6 2 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n          3 6 4 6 3 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n        */\n      pass(0, 0, 8, 8); // 1\n      /* NOTE these seem to follow the pattern:\n       * pass(x, 0, 2*x, 2*x);\n       * pass(0, x,   x, 2*x);\n       * with x being 4, 2, 1.\n       */\n      pass(4, 0, 8, 8); // 2\n      pass(0, 4, 4, 8); // 3\n\n      pass(2, 0, 4, 4); // 4\n      pass(0, 2, 2, 4); // 5\n\n      pass(1, 0, 2, 2); // 6\n      pass(0, 1, 1, 2); // 7\n    } else {\n      pass(0, 0, 1, 1);\n    }\n    return fullPixels;\n  };\n\n  PNG.prototype.decodePalette = function() {\n    var c, i, length, palette, pos, ret, transparency, _i, _ref, _ref1;\n    palette = this.palette;\n    transparency = this.transparency.indexed || [];\n    ret = new Uint8Array((transparency.length || 0) + palette.length);\n    pos = 0;\n    length = palette.length;\n    c = 0;\n    for (i = _i = 0, _ref = length; _i < _ref; i = _i += 3) {\n      ret[pos++] = palette[i];\n      ret[pos++] = palette[i + 1];\n      ret[pos++] = palette[i + 2];\n      ret[pos++] = (_ref1 = transparency[c++]) != null ? _ref1 : 255;\n    }\n    return ret;\n  };\n\n  PNG.prototype.copyToImageData = function(imageData, pixels) {\n    var alpha, colors, data, i, input, j, k, length, palette, v, _ref;\n    colors = this.colors;\n    palette = null;\n    alpha = this.hasAlphaChannel;\n    if (this.palette.length) {\n      palette =\n        (_ref = this._decodedPalette) != null\n          ? _ref\n          : (this._decodedPalette = this.decodePalette());\n      colors = 4;\n      alpha = true;\n    }\n    data = imageData.data || imageData;\n    length = data.length;\n    input = palette || pixels;\n    i = j = 0;\n    if (colors === 1) {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        v = input[k++];\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    } else {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    }\n  };\n\n  PNG.prototype.decode = function() {\n    var ret;\n    ret = new Uint8Array(this.width * this.height * 4);\n    this.copyToImageData(ret, this.decodePixels());\n    return ret;\n  };\n\n  var hasBrowserCanvas = function() {\n    if (Object.prototype.toString.call(globalObject) === \"[object Window]\") {\n      try {\n        scratchCanvas = globalObject.document.createElement(\"canvas\");\n        scratchCtx = scratchCanvas.getContext(\"2d\");\n      } catch (e) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  };\n\n  hasBrowserCanvas();\n\n  makeImage = function(imageData) {\n    if (hasBrowserCanvas() === true) {\n      var img;\n      scratchCtx.width = imageData.width;\n      scratchCtx.height = imageData.height;\n      scratchCtx.clearRect(0, 0, imageData.width, imageData.height);\n      scratchCtx.putImageData(imageData, 0, 0);\n      img = new Image();\n      img.src = scratchCanvas.toDataURL();\n      return img;\n    }\n    throw new Error(\"This method requires a Browser with Canvas-capability.\");\n  };\n\n  PNG.prototype.decodeFrames = function(ctx) {\n    var frame, i, imageData, pixels, _i, _len, _ref, _results;\n    if (!this.animation) {\n      return;\n    }\n    _ref = this.animation.frames;\n    _results = [];\n    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n      frame = _ref[i];\n      imageData = ctx.createImageData(frame.width, frame.height);\n      pixels = this.decodePixels(new Uint8Array(frame.data));\n      this.copyToImageData(imageData, pixels);\n      frame.imageData = imageData;\n      _results.push((frame.image = makeImage(imageData)));\n    }\n    return _results;\n  };\n\n  PNG.prototype.renderFrame = function(ctx, number) {\n    var frame, frames, prev;\n    frames = this.animation.frames;\n    frame = frames[number];\n    prev = frames[number - 1];\n    if (number === 0) {\n      ctx.clearRect(0, 0, this.width, this.height);\n    }\n    if (\n      (prev != null ? prev.disposeOp : void 0) === APNG_DISPOSE_OP_BACKGROUND\n    ) {\n      ctx.clearRect(prev.xOffset, prev.yOffset, prev.width, prev.height);\n    } else if (\n      (prev != null ? prev.disposeOp : void 0) === APNG_DISPOSE_OP_PREVIOUS\n    ) {\n      ctx.putImageData(prev.imageData, prev.xOffset, prev.yOffset);\n    }\n    if (frame.blendOp === APNG_BLEND_OP_SOURCE) {\n      ctx.clearRect(frame.xOffset, frame.yOffset, frame.width, frame.height);\n    }\n    return ctx.drawImage(frame.image, frame.xOffset, frame.yOffset);\n  };\n\n  PNG.prototype.animate = function(ctx) {\n    var doFrame,\n      frameNumber,\n      frames,\n      numFrames,\n      numPlays,\n      _ref,\n      _this = this;\n    frameNumber = 0;\n    (_ref = this.animation),\n      (numFrames = _ref.numFrames),\n      (frames = _ref.frames),\n      (numPlays = _ref.numPlays);\n    return (doFrame = function() {\n      var f, frame;\n      f = frameNumber++ % numFrames;\n      frame = frames[f];\n      _this.renderFrame(ctx, f);\n      if (numFrames > 1 && frameNumber / numFrames < numPlays) {\n        return (_this.animation._timeout = setTimeout(doFrame, frame.delay));\n      }\n    })();\n  };\n\n  PNG.prototype.stopAnimation = function() {\n    var _ref;\n    return clearTimeout(\n      (_ref = this.animation) != null ? _ref._timeout : void 0\n    );\n  };\n\n  PNG.prototype.render = function(canvas) {\n    var ctx, data;\n    if (canvas._png) {\n      canvas._png.stopAnimation();\n    }\n    canvas._png = this;\n    canvas.width = this.width;\n    canvas.height = this.height;\n    ctx = canvas.getContext(\"2d\");\n    if (this.animation) {\n      this.decodeFrames(ctx);\n      return this.animate(ctx);\n    } else {\n      data = ctx.createImageData(this.width, this.height);\n      this.copyToImageData(data, this.decodePixels());\n      return ctx.putImageData(data, 0, 0);\n    }\n  };\n\n  return PNG;\n})();\n\nexport { PNG };\n","/**\n * @license\n *\n * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n * ====================================================================\n */\n\nimport { jsPDF } from \"../jspdf.js\";\nimport { PNG } from \"../libs/png.js\";\n\n/**\n * jsPDF PNG PlugIn\n * @name png_support\n * @module\n */\n(function(jsPDFAPI) {\n  \"use strict\";\n\n  /*\n   * @see http://www.w3.org/TR/PNG-Chunks.html\n   *\n   Color    Allowed      Interpretation\n   Type     Bit Depths\n\n     0       1,2,4,8,16  Each pixel is a grayscale sample.\n\n     2       8,16        Each pixel is an R,G,B triple.\n\n     3       1,2,4,8     Each pixel is a palette index;\n                         a PLTE chunk must appear.\n\n     4       8,16        Each pixel is a grayscale sample,\n                         followed by an alpha sample.\n\n     6       8,16        Each pixel is an R,G,B triple,\n                         followed by an alpha sample.\n  */\n\n  /*\n   * PNG filter method types\n   *\n   * @see http://www.w3.org/TR/PNG-Filters.html\n   * @see http://www.libpng.org/pub/png/book/chapter09.html\n   *\n   * This is what the value 'Predictor' in decode params relates to\n   *\n   * 15 is \"optimal prediction\", which means the prediction algorithm can change from line to line.\n   * In that case, you actually have to read the first byte off each line for the prediction algorthim (which should be 0-4, corresponding to PDF 10-14) and select the appropriate unprediction algorithm based on that byte.\n   *\n     0       None\n     1       Sub\n     2       Up\n     3       Average\n     4       Paeth\n   */\n\n  var canCompress = function(value) {\n    return value !== jsPDFAPI.image_compression.NONE && hasCompressionJS();\n  };\n\n  var hasCompressionJS = function() {\n    return typeof zlibSync === \"function\";\n  };\n  var compressBytes = function(bytes, lineLength, colorsPerPixel, compression) {\n    var level = 4;\n    var filter_method = filterUp;\n\n    switch (compression) {\n      case jsPDFAPI.image_compression.FAST:\n        level = 1;\n        filter_method = filterSub;\n        break;\n\n      case jsPDFAPI.image_compression.MEDIUM:\n        level = 6;\n        filter_method = filterAverage;\n        break;\n\n      case jsPDFAPI.image_compression.SLOW:\n        level = 9;\n        filter_method = filterPaeth;\n        break;\n    }\n\n    bytes = applyPngFilterMethod(\n      bytes,\n      lineLength,\n      colorsPerPixel,\n      filter_method\n    );\n    var dat = zlibSync(bytes, { level: level });\n    return jsPDFAPI.__addimage__.arrayBufferToBinaryString(dat);\n  };\n\n  var applyPngFilterMethod = function(\n    bytes,\n    lineLength,\n    colorsPerPixel,\n    filter_method\n  ) {\n    var lines = bytes.length / lineLength,\n      result = new Uint8Array(bytes.length + lines),\n      filter_methods = getFilterMethods(),\n      line,\n      prevLine,\n      offset;\n\n    for (var i = 0; i < lines; i += 1) {\n      offset = i * lineLength;\n      line = bytes.subarray(offset, offset + lineLength);\n\n      if (filter_method) {\n        result.set(filter_method(line, colorsPerPixel, prevLine), offset + i);\n      } else {\n        var len = filter_methods.length,\n          results = [];\n\n        for (var j; j < len; j += 1) {\n          results[j] = filter_methods[j](line, colorsPerPixel, prevLine);\n        }\n\n        var ind = getIndexOfSmallestSum(results.concat());\n\n        result.set(results[ind], offset + i);\n      }\n\n      prevLine = line;\n    }\n\n    return result;\n  };\n\n  var filterNone = function(line) {\n    /*var result = new Uint8Array(line.length + 1);\n    result[0] = 0;\n    result.set(line, 1);*/\n\n    var result = Array.apply([], line);\n    result.unshift(0);\n\n    return result;\n  };\n\n  var filterSub = function(line, colorsPerPixel) {\n    var result = [],\n      len = line.length,\n      left;\n\n    result[0] = 1;\n\n    for (var i = 0; i < len; i += 1) {\n      left = line[i - colorsPerPixel] || 0;\n      result[i + 1] = (line[i] - left + 0x0100) & 0xff;\n    }\n\n    return result;\n  };\n\n  var filterUp = function(line, colorsPerPixel, prevLine) {\n    var result = [],\n      len = line.length,\n      up;\n\n    result[0] = 2;\n\n    for (var i = 0; i < len; i += 1) {\n      up = (prevLine && prevLine[i]) || 0;\n      result[i + 1] = (line[i] - up + 0x0100) & 0xff;\n    }\n\n    return result;\n  };\n\n  var filterAverage = function(line, colorsPerPixel, prevLine) {\n    var result = [],\n      len = line.length,\n      left,\n      up;\n\n    result[0] = 3;\n\n    for (var i = 0; i < len; i += 1) {\n      left = line[i - colorsPerPixel] || 0;\n      up = (prevLine && prevLine[i]) || 0;\n      result[i + 1] = (line[i] + 0x0100 - ((left + up) >>> 1)) & 0xff;\n    }\n\n    return result;\n  };\n\n  var filterPaeth = function(line, colorsPerPixel, prevLine) {\n    var result = [],\n      len = line.length,\n      left,\n      up,\n      upLeft,\n      paeth;\n\n    result[0] = 4;\n\n    for (var i = 0; i < len; i += 1) {\n      left = line[i - colorsPerPixel] || 0;\n      up = (prevLine && prevLine[i]) || 0;\n      upLeft = (prevLine && prevLine[i - colorsPerPixel]) || 0;\n      paeth = paethPredictor(left, up, upLeft);\n      result[i + 1] = (line[i] - paeth + 0x0100) & 0xff;\n    }\n\n    return result;\n  };\n\n  var paethPredictor = function(left, up, upLeft) {\n    if (left === up && up === upLeft) {\n      return left;\n    }\n    var pLeft = Math.abs(up - upLeft),\n      pUp = Math.abs(left - upLeft),\n      pUpLeft = Math.abs(left + up - upLeft - upLeft);\n    return pLeft <= pUp && pLeft <= pUpLeft\n      ? left\n      : pUp <= pUpLeft\n      ? up\n      : upLeft;\n  };\n\n  var getFilterMethods = function() {\n    return [filterNone, filterSub, filterUp, filterAverage, filterPaeth];\n  };\n\n  var getIndexOfSmallestSum = function(arrays) {\n    var sum = arrays.map(function(value) {\n      return value.reduce(function(pv, cv) {\n        return pv + Math.abs(cv);\n      }, 0);\n    });\n    return sum.indexOf(Math.min.apply(null, sum));\n  };\n\n  var getPredictorFromCompression = function(compression) {\n    var predictor;\n    switch (compression) {\n      case jsPDFAPI.image_compression.FAST:\n        predictor = 11;\n        break;\n\n      case jsPDFAPI.image_compression.MEDIUM:\n        predictor = 13;\n        break;\n\n      case jsPDFAPI.image_compression.SLOW:\n        predictor = 14;\n        break;\n\n      default:\n        predictor = 12;\n        break;\n    }\n    return predictor;\n  };\n\n  /**\n   * @name processPNG\n   * @function\n   * @ignore\n   */\n  jsPDFAPI.processPNG = function(imageData, index, alias, compression) {\n    \"use strict\";\n\n    var colorSpace,\n      filter = this.decode.FLATE_DECODE,\n      bitsPerComponent,\n      image,\n      decodeParameters = \"\",\n      trns,\n      colors,\n      pal,\n      smask,\n      pixels,\n      len,\n      alphaData,\n      imgData,\n      hasColors,\n      pixel,\n      i,\n      n;\n\n    if (this.__addimage__.isArrayBuffer(imageData))\n      imageData = new Uint8Array(imageData);\n\n    if (this.__addimage__.isArrayBufferView(imageData)) {\n      image = new PNG(imageData);\n      imageData = image.imgData;\n      bitsPerComponent = image.bits;\n      colorSpace = image.colorSpace;\n      colors = image.colors;\n\n      /*\n       * colorType 6 - Each pixel is an R,G,B triple, followed by an alpha sample.\n       *\n       * colorType 4 - Each pixel is a grayscale sample, followed by an alpha sample.\n       *\n       * Extract alpha to create two separate images, using the alpha as a sMask\n       */\n      if ([4, 6].indexOf(image.colorType) !== -1) {\n        /*\n         * processes 8 bit RGBA and grayscale + alpha images\n         */\n        if (image.bits === 8) {\n          pixels =\n            image.pixelBitlength == 32\n              ? new Uint32Array(image.decodePixels().buffer)\n              : image.pixelBitlength == 16\n              ? new Uint16Array(image.decodePixels().buffer)\n              : new Uint8Array(image.decodePixels().buffer);\n          len = pixels.length;\n          imgData = new Uint8Array(len * image.colors);\n          alphaData = new Uint8Array(len);\n          var pDiff = image.pixelBitlength - image.bits;\n          i = 0;\n          n = 0;\n          var pbl;\n\n          for (; i < len; i++) {\n            pixel = pixels[i];\n            pbl = 0;\n\n            while (pbl < pDiff) {\n              imgData[n++] = (pixel >>> pbl) & 0xff;\n              pbl = pbl + image.bits;\n            }\n\n            alphaData[i] = (pixel >>> pbl) & 0xff;\n          }\n        }\n\n        /*\n         * processes 16 bit RGBA and grayscale + alpha images\n         */\n        if (image.bits === 16) {\n          pixels = new Uint32Array(image.decodePixels().buffer);\n          len = pixels.length;\n          imgData = new Uint8Array(\n            len * (32 / image.pixelBitlength) * image.colors\n          );\n          alphaData = new Uint8Array(len * (32 / image.pixelBitlength));\n          hasColors = image.colors > 1;\n          i = 0;\n          n = 0;\n          var a = 0;\n\n          while (i < len) {\n            pixel = pixels[i++];\n\n            imgData[n++] = (pixel >>> 0) & 0xff;\n\n            if (hasColors) {\n              imgData[n++] = (pixel >>> 16) & 0xff;\n\n              pixel = pixels[i++];\n              imgData[n++] = (pixel >>> 0) & 0xff;\n            }\n\n            alphaData[a++] = (pixel >>> 16) & 0xff;\n          }\n          bitsPerComponent = 8;\n        }\n\n        if (canCompress(compression)) {\n          imageData = compressBytes(\n            imgData,\n            image.width * image.colors,\n            image.colors,\n            compression\n          );\n          smask = compressBytes(alphaData, image.width, 1, compression);\n        } else {\n          imageData = imgData;\n          smask = alphaData;\n          filter = undefined;\n        }\n      }\n\n      /*\n       * Indexed png. Each pixel is a palette index.\n       */\n      if (image.colorType === 3) {\n        colorSpace = this.color_spaces.INDEXED;\n        pal = image.palette;\n\n        if (image.transparency.indexed) {\n          var trans = image.transparency.indexed;\n          var total = 0;\n          i = 0;\n          len = trans.length;\n\n          for (; i < len; ++i) {\n            total += trans[i];\n          }\n\n          total = total / 255;\n\n          /*\n           * a single color is specified as 100% transparent (0),\n           * so we set trns to use a /Mask with that index\n           */\n          if (total === len - 1 && trans.indexOf(0) !== -1) {\n            trns = [trans.indexOf(0)];\n\n            /*\n             * there's more than one colour within the palette that specifies\n             * a transparency value less than 255, so we unroll the pixels to create an image sMask\n             */\n          } else if (total !== len) {\n            pixels = image.decodePixels();\n            alphaData = new Uint8Array(pixels.length);\n            i = 0;\n            len = pixels.length;\n\n            for (; i < len; i++) {\n              alphaData[i] = trans[pixels[i]];\n            }\n\n            smask = compressBytes(alphaData, image.width, 1);\n          }\n        }\n      }\n\n      var predictor = getPredictorFromCompression(compression);\n\n      if (filter === this.decode.FLATE_DECODE) {\n        decodeParameters = \"/Predictor \" + predictor + \" \";\n      }\n      decodeParameters +=\n        \"/Colors \" +\n        colors +\n        \" /BitsPerComponent \" +\n        bitsPerComponent +\n        \" /Columns \" +\n        image.width;\n\n      if (\n        this.__addimage__.isArrayBuffer(imageData) ||\n        this.__addimage__.isArrayBufferView(imageData)\n      ) {\n        imageData = this.__addimage__.arrayBufferToBinaryString(imageData);\n      }\n\n      if (\n        (smask && this.__addimage__.isArrayBuffer(smask)) ||\n        this.__addimage__.isArrayBufferView(smask)\n      ) {\n        smask = this.__addimage__.arrayBufferToBinaryString(smask);\n      }\n\n      return {\n        alias: alias,\n        data: imageData,\n        index: index,\n        filter: filter,\n        decodeParameters: decodeParameters,\n        transparency: trns,\n        palette: pal,\n        sMask: smask,\n        predictor: predictor,\n        width: image.width,\n        height: image.height,\n        bitsPerComponent: bitsPerComponent,\n        colorSpace: colorSpace\n      };\n    }\n  };\n})(jsPDF.API);\n","import { jsPDF } from \"./jspdf.js\";\nimport \"./modules/addimage.js\";\nimport \"./modules/png_support.js\";\n\nexport function png2pdf(config) {\n    const orientation = config.pageWidth > config.pageHeight ? \"l\" : \"p\";\n    var doc = new jsPDF({ format: [config.pageWidth, config.pageHeight], orientation });\n    for (var i = 0, iLen = config.pages.length; i < iLen; i++ ) {\n        var images = config.pages[i];\n        for (var p = 0, pLen = images.length; p < pLen; p++ ) {\n            var image = images[p];\n            doc.addImage(image.dataUrl, \"PNG\", image.x, image.y, image.w, image.h);\n        }\n        if (i < iLen - 1) {\n            doc.addPage();\n        }\n    }\n    return doc.output(\"arraybuffer\");\n}\n"],"names":["atob","btoa","globalObject","window","global","self","this","consoleLog","console","log","apply","arguments","bind","warn","str","call","error","PubSub","context","_typeof","Error","topics","subscribe","topic","callback","once","hasOwnProperty","token","Math","random","toString","unsubscribe","Object","keys","length","publish","args","Array","prototype","slice","tokens","sub","ex","message","push","forEach","getTopics","jsPDF","options","precision","orientation","unit","format","compressPdf","filters","userUnit","floatPrecision","compress","abs","toLowerCase","API","internal","__private__","pdfVersion","getPdfVersion","setPdfVersion","value","ApiMode","COMPAT","ADVANCED","apiMode","isAdvancedAPI","creationDate","roundToPrecision","number","parmPrecision","tmpPrecision","isNaN","toFixed","replace","hpf","scale","scaleFactor","fileId","getFileId","setFileId","test","toUpperCase","split","map","charAt","floor","join","convertDateToPDFDate","parmDate","tzoffset","getTimezoneOffset","tzsign","tzhour","tzmin","timeZoneString","padd2","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","convertPDFDateToDate","parmPDFDate","year","parseInt","substr","month","date","hour","minutes","seconds","Date","setCreationDate","tmpCreationDateString","getCreationDate","type","result","currentPage","pageMode","layoutMode","objectNumber","offsets","content","contentLength","additionalObjects","pages","outputDestination","resetDocument","rootDictionaryObjId","newObjectDeferred","resourceDictionaryObjId","setOutputDestination","destination","out","string","write","getArrayBuffer","data","len","ab","ArrayBuffer","u8","Uint8Array","charCodeAt","getPageMode","getLayoutMode","activeFontKey","documentProperties","title","subject","author","keywords","creator","fonts","page","pagesContext","events","hotfixes","renderTargets","newObject","matrixMult","m1","m2","multiply","oid","newObjectDeferredBegin","doOutput","newAdditionalObject","obj","objId","getFilters","putStream","alreadyAppliedFilters","addLength1","valueOfLength1","processedData","keyValues","additionalKeyValues","filterAsString","processDataByFilters","reverseChain","isArray","key","j","decodeParmsArray","i","k","putPage","pageNumber","pageObjectNumber","pageContentsObjId","contentsObjId","parseFloat","mediaBox","bottomLeftX","bottomLeftY","topRightX","topRightY","cropBox","bleedBox","trimBox","artBox","pageContext","pageContent","objectId","putPages","n","pageObjectNumbers","kids","putXobjectDict","xObjectKey","putResourceDictionary","objectIds","resourcesOid","putResources","objectOid","Number","MAX_SAFE_INTEGER","SAFE","fn","foo","e","stack","indexOf","m","alert","bar","to8bitStream","text","flags","l","sourceEncoding","encodingBlock","outputEncoding","newtext","isUnicode","ch","bch","autoencode","metadata","encoding","codePages","String","fromCharCode","undefined","noBOM","pdfEscape","beginPage","_setPage","_addPage","parmFormat","width","height","min","getNumberOfPages","putInfo","version","putCatalog","tmpRootDictionaryObjId","putTrailer","putHeader","putXRef","p","buildDocument","offsetOfXRef","output","filename","dataURI","pdfDocument","unescape","encodeURIComponent","hasHotfix","hotfixName","addPage","isValidStyle","style","close","getHorizontalCoordinate","getVerticalCoordinate","getHorizontalCoordinateString","getVerticalCoordinateString","plugin","newEvents","eventname","handler_and_args","concat","getCoordinateString","collections","getPDFVersion","jsPDFAPI","__addimage__","putImage","image","filter","splice","colorSpace","color_spaces","INDEXED","palette","sMask","DEVICE_CMYK","bitsPerComponent","decodeParameters","transparency","predictor","arrayBufferToBinaryString","putResourcesCallback","images","putXObjectsDictCallback","index","initialize","getImages","getImageIndex","isImageTypeSupported","checkImagesForAlias","alias","determineWidthAndHeight","writeImageToPDF","x","y","rotation","dims","coord","vcoord","PI","c","cos","s","sin","f4","rotationTransformationMatrix","DEVICE_RGB","DEVICE_GRAY","CAL_GREY","CAL_RGB","LAB","ICC_BASED","PATTERN","SEPARATION","DEVICE_N","decode","DCT_DECODE","FLATE_DECODE","LZW_DECODE","JPX_DECODE","JBIG2_DECODE","ASCII85_DECODE","ASCII_HEX_DECODE","RUN_LENGTH_DECODE","CCITT_FAX_DECODE","image_compression","NONE","FAST","MEDIUM","SLOW","sHashCode","hash","isArrayBufferView","byteLength","validateStringAsBase64","possibleBase64String","trim","extractImageFromDataUrl","dataUrl","dataUrlParts","extractedInfo","exec","mimeType","charset","supportsArrayBuffer","isArrayBuffer","object","Uint32Array","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Float32Array","Float64Array","binaryStringToUint8Array","binary_string","bytes","buffer","buf","subarray","addImage","imageData","w","h","compression","processImageData","dataAsBinaryString","convertBase64ToBinaryString","generateAliasFromImageData","checkCompressValue","stringData","throwError","base64Info","rawData","getImageProperties","fileType","require","Worker","u16","u32","fleb","fdeb","clim","freb","eb","start","b","r","_a","fl","revfl","fd","rev","hMap","cd","mb","co","le","rvb","sv","r_1","v","flt","fdt","flrm","fdrm","max","a","bits","d","o","bits16","inflt","dat","st","sl","noBuf","noSt","cbuf","bl","nbuf","set","final","f","pos","bt","lm","dm","lbt","dbt","tbts","t","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","lt","dt","lms","dms","mxa","sym","add","dsym","end","slc","hasCompressionJS","compressBytes","applyPngFilterMethod","filterNone","filterSub","filterUp","filterAverage","filterPaeth","paethPredictor","getFilterMethods","getIndexOfSmallestSum","PNG","makeImage","scratchCanvas","scratchCtx","chunkSize","colors","palLen","delayDen","delayNum","frame","section","palShort","_i","_j","_ref","imgData","animation","readUInt32","_results","colorType","compressionMethod","filterMethod","interlaceMethod","numFrames","numPlays","Infinity","frames","read","xOffset","yOffset","readUInt16","delay","disposeOp","blendOp","indexed","grayscale","rgb","hasAlphaChannel","pixelBitlength","decodePixels","pixelBytes","fullPixels","_this","pass","x0","y0","dx","dy","abyte","col","left","pa","paeth","pb","pc","pixels","row","scanlineLength","upper","upperLeft","_k","_l","_m","ceil","isFull","fullPos","partPos","zlv","unzlibSync","decodePalette","ret","_ref1","copyToImageData","alpha","input","_decodedPalette","hasBrowserCanvas","document","createElement","getContext","img","clearRect","putImageData","Image","src","toDataURL","decodeFrames","ctx","_len","createImageData","renderFrame","prev","drawImage","animate","doFrame","frameNumber","_timeout","setTimeout","stopAnimation","clearTimeout","render","canvas","_png","zlibSync","lineLength","colorsPerPixel","level","filter_method","line","prevLine","offset","lines","filter_methods","results","ind","unshift","up","upLeft","pLeft","pUp","pUpLeft","arrays","sum","reduce","pv","cv","processPNG","trns","pal","smask","alphaData","hasColors","pixel","pbl","pDiff","trans","total","getPredictorFromCompression","config","pageWidth","pageHeight","doc","iLen","pLen"],"mappings":"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"}